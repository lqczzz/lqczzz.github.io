{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lqczzz","url":"http://lqczzz.github.io"},"pages":[{"title":"关于","date":"2018-10-12T22:32:51.000Z","updated":"2018-10-12T22:32:51.000Z","comments":false,"path":"about/index.html","permalink":"http://lqczzz.github.io/about/index.html","excerpt":"","text":"关于我 English Name: Lance 华南理工大学 17届信息工程电联班 本科 2016.7 - 2018.5 华为[深圳] 2018.5 - 今 shopee[深圳] 会点啥关于前端的 1. angular 2. vue[主] 3. react 关于后端 1. java web (springboot/jersey/mybatis/springcloud) 2. python flask/django 3. node express/koa/eggjs 4. golang （目前主力开发语言） 爱好1. 尤克里里 2. Magicavoxel 3. 旅游分享 [我的马蜂窝](http://www.mafengwo.cn/u/35061852.html) 4. 不玩游戏，但也不是绝对"},{"title":"书单","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":false,"path":"books/index.html","permalink":"http://lqczzz.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":false,"path":"categories/index.html","permalink":"http://lqczzz.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":true,"path":"links/index.html","permalink":"http://lqczzz.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":false,"path":"tags/index.html","permalink":"http://lqczzz.github.io/tags/index.html","excerpt":"","text":"tags: 文章标签 文章标签 文章标签"}],"posts":[{"title":"知识管理","slug":"知识管理","date":"2018-10-14T03:06:31.000Z","updated":"2018-10-14T11:48:01.000Z","comments":true,"path":"2018/10/14/知识管理/","link":"","permalink":"http://lqczzz.github.io/2018/10/14/知识管理/","excerpt":"","text":"为什么这样分类笔记用于我对知识的掌握，工作快两年了我才发现了知识的几个特点： 很多知识机靠记忆是没办法持久化存储的 比如前端vue框架，我用了大半年了，发现才转后台3个月，vue的很多东西就忘的差不多了 比如spring相关的框架，从大学开始使用到现在，断断续续，每次重新使用都得重新学习一遍，虽然每次学习的时间会越来越缩短。 比如开发工具，使用的编辑器的快捷键的使用等，都是很容易遗忘但是有没必要刻意去记住的 很多知识是细枝末节的 比如\b某种框架，框架其实是一种架构良好的工具，提供了某种不变的东西，让你快速实现某种变化，来适应不同的业务场景。比如spring系的的框架，模版设计模式就很常用，你只要继承某种基类，然后实现特定的抽象函数（钩子函数），就能完成一个不同的功能，而前端框架vue的组件化就是最明显的模板模式的应用。框架是一种工具，工具的实现和接口都是细枝末节的，就算完全忘记了，只要拿上一个上午的时间甚者更短，就能再次掌握起来了。 在华为曾做过一个项目，后台开始是用node实现的，领导觉得node不安全，于是让我们用java重构，并且做好服务化，我们把微服务当作银弹，结果重构之后更加难部署了，项目的规模也没有达到必须使用服务化的必要。这就是锤子理论，拿起锤子，觉得什么都是钉子。 很多知识是可以进行类比的 比如web框架，不管是node的koa，python的flask还是golang的gin，都是有很多通用的概念，常用的套路，相同的业务场景和解决方案，举一反三对掌握新的工具是很有用的 很多知识是可以快速掌握和应用的 分类的策略 入门类：对概念和基本流程有一个基本的认识 笔记类： 常用的用法的记录 原理类： 对入门类有更详细的认识 实战类： 具体场景下的使用","categories":[],"tags":[]},{"title":"elasticSearch学习笔记","slug":"elasticSearch学习笔记","date":"2018-10-13T14:29:32.000Z","updated":"2018-10-13T15:03:26.000Z","comments":true,"path":"2018/10/13/elasticSearch学习笔记/","link":"","permalink":"http://lqczzz.github.io/2018/10/13/elasticSearch学习笔记/","excerpt":"","text":"elasticSearch入门最近在项目中遇到了需要搜索引擎的场景，对用户输入进行自动推荐和补全，elasticSearch是\b开源的搜索引引擎，入门使用也很简单。 怎么入门： 类比入门：类比一个熟悉的知识点，知识迁移\b会更容易 简单的事例入门：动手进行简单的一个demo感受一下流程 入门1.安装es前置条件：mac环境(其他环境自行google)，brew工具安装好了，java环境安装好了 步骤： 安装es： brew install elasticsearch es服务端会被安装 安装kibana： brew install kibana kibana可以理解为图形化的es客户端 启动es：brew services start elasticsearch 安装es成功之后访问http://localhost:9200/可以获得es的状态信息安装kibana成功之后访问http://localhost:5601/app/kibana#/dev_tools/console?_g=()可以对es进行操作 2.自动补全// hashtag { id, name, score, // weight } mappings &amp; analysizerPUT feed_id { &quot;mappings&quot;: { &quot;hashtag&quot;: { &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;completion&quot; } } } } } 添加数据POST feed_id/hashtag { &quot;name&quot;: { &quot;input&quot;: [&quot;hashtag name&quot;], &quot;weight&quot;: 2 } } POST feed_id/hashtag/3 { &quot;name&quot;: { &quot;input&quot;: [&quot;hashtag name2&quot;], &quot;weight&quot;: 3 } } POST feed_id/hashtag/4 { &quot;name&quot;: { &quot;input&quot;: [&quot;ashtag name2&quot;], &quot;weight&quot;: 4 } } POST feed_id/hashtag/5 { &quot;name&quot;: { &quot;input&quot;: [&quot;shtag name2&quot;], &quot;weight&quot;: 5 } } POST feed_id/hashtag/6 { &quot;name&quot;: { &quot;input&quot;: [&quot;htag name2&quot;], &quot;weight&quot;: 6 } } POST feed_id/hashtag/7 { &quot;name&quot;: { &quot;input&quot;: [&quot;爱我中华&quot;], &quot;weight&quot;: 6 } } POST feed_id/hashtag/8 { &quot;name&quot;: { &quot;input&quot;: [&quot;爱你中华&quot;], &quot;weight&quot;: 6 } } POST feed_id/hashtag/9 { &quot;name&quot;: { &quot;input&quot;: [&quot;爱你&quot;], &quot;weight&quot;: 6 } } 查询数据POST feed_id/_search?pretty { &quot;suggest&quot;: { &quot;hashtag-suggest&quot;: { &quot;prefix&quot;: &quot;h&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;name&quot; } } } } 基本概念摘抄自elasticsearch-definitive-guide-cn 参考：","categories":[],"tags":[]},{"title":"记timeline重构","slug":"记timeline重构","date":"2018-10-12T22:28:45.000Z","updated":"2018-10-14T03:15:20.000Z","comments":true,"path":"2018/10/13/记timeline重构/","link":"","permalink":"http://lqczzz.github.io/2018/10/13/记timeline重构/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"golang并发","slug":"golang并发","date":"2018-10-12T22:28:05.000Z","updated":"2018-10-14T12:58:47.000Z","comments":true,"path":"2018/10/13/golang并发/","link":"","permalink":"http://lqczzz.github.io/2018/10/13/golang并发/","excerpt":"","text":"golang的并发模型叫做CSP（communicating sequential process），称为通信顺序进程模型，模型由独立并发执行的实体组成（go块），模型之间的通信通过channel来实现。因此，golang的并发模型哲学是：万物皆通信！！golang的核心概念主要是： channel go块 channel channel可以单独创建，在进程之间传递 channel是线程安全队列，任何持有channel引用的任务(go块)都可以读写channel channel默认是无缓冲区的，也就是channel本身是同步的，一端写数据操作必然会阻塞直到channel的数据被别的地方读取 channel可以关闭，向关闭的channel读数据会读到的默认值，向关闭的channel写数据会导致panic！！ func main() { ch := make(chan int) go func() { ch &lt;- 20 close(ch) ch &lt;- 30 //panic: send on closed channel }() println(&lt;-ch) // 20 println(&lt;-ch) // 0(默认值) } 有缓冲区的channel，根据缓冲区已满时候的策略，可以分为 阻塞型：写入阻塞 弃用新值：新值写入被抛弃 移除旧值：太旧的数据被channel抛弃 goroutinego块","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://lqczzz.github.io/tags/golang/"},{"name":"并发","slug":"并发","permalink":"http://lqczzz.github.io/tags/并发/"}]}]}