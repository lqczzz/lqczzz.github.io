{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"lqczzz","url":"http://lqczzz.github.io"},"pages":[{"title":"关于","date":"2018-10-12T22:32:51.000Z","updated":"2018-10-12T22:32:51.000Z","comments":false,"path":"about/index.html","permalink":"http://lqczzz.github.io/about/index.html","excerpt":"","text":"关于我 English Name: Lance 华南理工大学 17届信息工程电联班 本科 2016.7 - 2018.5 华为[深圳] 2018.5 - 今 shopee[深圳] 会点啥关于前端的 1. angular 2. vue[主] 3. react 关于后端 1. java web (springboot/jersey/mybatis/springcloud) 2. python flask/django 3. node express/koa/eggjs 4. golang （目前主力开发语言） 爱好1. 尤克里里 2. Magicavoxel 3. 旅游分享 [我的马蜂窝](http://www.mafengwo.cn/u/35061852.html) 4. 不玩游戏，但也不是绝对"},{"title":"书单","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":false,"path":"books/index.html","permalink":"http://lqczzz.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":false,"path":"categories/index.html","permalink":"http://lqczzz.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":true,"path":"links/index.html","permalink":"http://lqczzz.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-12T21:48:40.000Z","updated":"2018-10-12T21:48:40.000Z","comments":false,"path":"tags/index.html","permalink":"http://lqczzz.github.io/tags/index.html","excerpt":"","text":"tags: 文章标签 文章标签 文章标签"}],"posts":[{"title":"break 和 continue","slug":"break-in-golang","date":"2018-10-26T10:49:42.000Z","updated":"2018-10-26T13:40:17.000Z","comments":true,"path":"2018/10/26/break-in-golang/","link":"","permalink":"http://lqczzz.github.io/2018/10/26/break-in-golang/","excerpt":"","text":"golang的break和continue挺好用的，和别的语言不太\b一样 breakgolang的break关键字for,switch,select会跳出三个关键字的包裹 A “break” statement terminates execution of the innermost “for”, “switch”, or “select” statement within the same function. —— 《The Go Programming Language Specification》 下面一段代码 for i := 0; i &lt; 6; i++ { switch i { case 2: break default: fmt.Println(i) } } // go run main.go： // 0 // 1 // 3 // 4 // 5 如果想跳出更上一层的for关键字，需要指定label forLoop: for i := 0; i &lt; 6; i++ { switch i { case 2: break forLoop default: fmt.Println(i) } } // go run main.go: // 0 // 1 continuecontinue也可以指定label forLoop: for i := 0; i &lt; 6; i++ { switch i { case 2: continue forLoop default: fmt.Println(i) } } // go run main.go // 0 // 1 // 3 // 4 // 5","categories":[],"tags":[{"name":"golang思考","slug":"golang思考","permalink":"http://lqczzz.github.io/tags/golang思考/"}]},{"title":"slice的坑","slug":"slice的坑","date":"2018-10-26T03:53:12.000Z","updated":"2018-10-26T03:54:31.000Z","comments":true,"path":"2018/10/26/slice的坑/","link":"","permalink":"http://lqczzz.github.io/2018/10/26/slice的坑/","excerpt":"","text":"坑1:type sli struct{ a []int } func (s *sli) sliceRet() []int { return s.a } func TestSliceTest(t *testing.T) { // what if case 1 // sl := &amp;sli{a: make([]int, 0, 3)} // what if case 2 sl := &amp;sli{a: make([]int, 3)} fmt.Printf(&quot;sl.a: %v, addr: %p\\n&quot;, sl.a, sl.a) b := sl.sliceRet() json.Unmarshal([]byte(&quot;[3,4,5]&quot;), &amp;b) fmt.Printf(&quot;b: %v, addr: %p\\n&quot;, b, b) fmt.Printf(&quot;sl.a: %v, addr: %p\\n&quot;, sl.a, sl.a) }","categories":[],"tags":[]},{"title":"unix网络编程笔记-tcp编程基础","slug":"unix网络编程笔记-tcp编程基础","date":"2018-10-21T06:00:26.000Z","updated":"2018-10-24T15:24:33.000Z","comments":true,"path":"2018/10/21/unix网络编程笔记-tcp编程基础/","link":"","permalink":"http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/","excerpt":"","text":"\b关于《unix网络编程》unix网络编程这书分为两册： 一册讲socket编程，700多页，31章 二册讲进程之间的通信，400页，16章 看目录可以看出，最基础最核心的知识在： chapter1: 简介 chapter2: tcp／udp和stcp(这玩意不管) chapter3: 套接字编程简介 chapter4: 基本tcp套接字编程 chapter5: tcp客户／服务端程序实例 chapter30: 客户／服务程序设计范式 感觉这几章学完了就差不多够了，其他章节\b需要再读～ 阅读前提假设你对OSI七层模型有所了解 chapter0:简介从现代交换技术说起《现代交换技术》是通信专业的必修课，嗯嗯，好歹我也是通信专业的学生，就先把知识脉络拓展一下～ 现代交换技术的分类： 电路交换 分组交换 计算机网络的协议用的就是分组交换技术，我们发送的信息会像快递包裹一样一个个的传送到接收方。而电路交换很简单，就是每个通信实体都连接到交换机上，而交换机使用交换的方法，让实体之间可以很方便地通信，现在最广泛的应用就是电话网络了。从打电话也可以看出来，电路交换一定是： 面向连接；(分组交换则不一定，如udp协议) 同步时分复用； 信息传送无差错控制； chapter1:分组交换协议 PDU: 协议数据单元，即对等实体(处于同一层)之间的交换单元信息 SDU: 下一层承载上一层数据的单元，比如tcp层传输的tcp报文(报文头+报文体)数据在tcp层就是一个PDU，传给ip层之后，ip层认为它是SDU（ip层在tcp报文之外加入ip报文头，类似俄罗斯套娃） 不同协议之间的不同完全取决于协议头（废话～） tcp／ip简介 一般认为web服务器程序是长时间运行的程序，即所谓的守护程序 用户进程定义应用协议，tcp和ip协议的转换和包装在内核协议栈中，由操作系统提供支持 tcp是没有记录边界的字节流协议 tcp\b应用进程之间\u001c是没有长度限制的字节流，udp进程交换的数据长度不能超过udp发送缓冲区大小的单个记录(record) tcp\b协议：应用程序一次次输出操作写到socket的数据经过顺序分割，得到分节(segment)，\b数据量太大的时候，我们无法确保一次read到所有的数据，所以必须要把read编写在某个循环中 tcp没有边界,所以tcp服务需要自己实现，提供一个表示长度的协议头 ip报文的SDU最大是65535，所以tcp一次发送的报文大小不会超过64k 对于\b平常实用的conn.Write([]byte)，我们是不用考虑这些，操作系统会对这类阻塞写操作进行自动分片并且不用考虑缓冲区写满的情况 套接字编程是应用层进入传输层的接口 这样设计由两个理由： 应用层对通信细节很少关心，而底下四层对应用协议不关心，只关心如何通信 应用层常构成用户进程，地下四层作为操作系统和内核的机制，存在与内核态 socket可以绕过tcp和udp直接实用ipv4/ipv6，这种socket称为原始套接字(raw socket),很少用到，在整本书里面第28章介绍了它的两个用途： ping traceroute因此不打算深入了解了 netstat和ifconfig可以很方便的查看网络的细节 案例分析bug这里记录一个工作中遇到的bug： // 没有for循环读取数据 func request(conn net.Conn, buffer bytes.Buffer, command []byte) error { // 读协议头，得到body的长度 recvBuf := make([]byte, 4) resHead := binary.LittleEndian.Uint32(recvBuf) // \b指定\b读取数据的大小，读取数据，bug:读取不完整 var resBody bytes.Buffer recvBuf = make([]byte, resHead) length, err := conn.Read(recvBuf) if err != nil { return err } return nil } bug分析： 原因 原因1: \bsocket上的read和write(操作系统的系统调用)不同于通常的文件读写，可能的到的字节数比预期的\b要少，原因在于内核缓冲区可能数据不够(read)或者缓冲区已经满了(non block write),上面的主要问题是read的时候缓冲区的数据不够，在项目中，由于网络原因，当我们 var recvData = make([]byte, Size) conn.Read(recvData) \b\b这样获取数据，由于网络不稳定，可能缓冲区的数据足够，可能不够，所以出现了调用20次成功一次的情况既然如此,为什么go实现conn.Read()为什么不帮我们阻塞去等待数据的到来呢 很遗憾Read没有这样的能力，go也没有提供类似c的Readn这样的接口 If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.来自 go io包Read接口的注释 原因2: 不知道服务器端发送的逻辑(也不应该依赖它)，可能是 for { conn.Write() // 手动分片 } 也可能是： conn.Write([]整个数据) 解决套一层for循环 // 修改成for循环读取数据，bug解决 func request(conn net.Conn, buffer bytes.Buffer, command []byte) error { // 读协议头，得到body的长度 recvBuf := make([]byte, 4) resHead := binary.LittleEndian.Uint32(recvBuf) // \b指定\b读取数据的大小，读取数据，bug:读取不完整 var resBody bytes.Buffer recvBuf = make([]byte, resHead) for resBody.Len() &lt; int(resHead) { length, err := conn.Read(recvBuf) if err != nil { return err } resBody.Write(recvBuf[:length]) } return nil } chapter2:传输层：tcp/udp/sctp主要讲了UDP／TCP／SCTP三种协议，SCTP日常用的少，以后再了解，重点讲了TCP编程，部分笔记来自第三章(方便总结) TCP/UDP协议族 ipv4/ipv6对上层协议提供了分组递送的能力，不具有可靠性(丢包可能) tcp是面向连接的流式套接字(stream socket)，关心确认／超时／重传的细节 需要三次握手建立连接 源端数据发送需要对端确认，一段时间内(超时时间:RTT)收不到确认应答则重传，多次重传失败则终止传输 RTT(round-trip time)一次客户端和服务器端往返时间 流量控制：接收方可以告诉发送方下一次我能接受的数据量，防止接收方缓冲区溢出 tcp是全双工的 udp是一种无连接的数据包报套接字(datagram socket)： 不保证是否到达 不保证到达顺序 没有自动重传 没有超时概念 每个数据包都都有报文头标示长度等 三次握手和四次挥手三次握手 上图来自第五章，展示了基本的一个tcp客户端和服务端的socket系统调用函数的关系，具体每个系统调用的作用在下面总结。\b这里关心的是三次握手触发的时机:服务端调用了accept，客户端调用connect主动打开 四次挥手 主动关闭方(客户端)发送fin分节，意思是我该说的说完了，服务器收到立马回复说我收到了,然后这个分节放到服务端的缓冲区的末尾，等待应用程序处理 应用程序处理完了，服务端也需要发一个fin告诉客户端我也完事了 在服务端发送这两个分节的过程中，服务端仍然可以向客户端发送数据 缓冲队列没有数据，服务端也不需要发送数据的时候，服务端会\b合并发送ack m+1和fin n分节，这时候就是三次挥手了。 主动关闭方(客户端)响应了服务端的fin分节之后，会再等一段时间，进入time_wait状态， tcp是全双工的，任何一方都可以\b关闭，通常是客户端关闭 tcp状态转换 time_wait状态 可靠的实现全双工连接的终止： 如果最后一个ack n+1没有发送给服务端，服务端会重新发送FIN N，这种情况至少花费一次来回(&gt;=2MSL)，因此time_wait需要有至少2MSL的时间间隔 允许老的重复分节消逝，主要是防止新的连接如果用了同样的ip和端口，被认为和上一次是同一个连接 socket pairsocket pair即(src_ip, src_port, dest_ip, dest_port)唯一确认一个tcp连接 如上图，当两个客户端连接同一个socket的时候，无法通过服务端socket的ip和port唯一确认一个连接。详细原因看chapter4 chapter3:套接字编程简介 网际协议采用大端字节传递多字节数（网络字节序） 大端字节序：高位内存地址对应高序字节 小端字节序：低位内存地址对应高序字节 chapter4:基本tcp套接字编程1. socket函数// 执行网络io前的第一步：socket() #include&lt;sys/socket.h&gt; int socket(int family, int type, int protocol) family type protocol socket函数调用成功会返回一个\b套接字描述符(类似文件描述符),只要指定协议族和套接字类型。 套接字(socket)和套接字描述符(discriptor)是一对多的关系（一个socket可以有对应多个discriptor） 2. connect函数客户端调用connect函数建立tcp连接，调用connect之前不必调用bind，系统会确定源ip地址并且默认选择一个临时端口作为源端口。 int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen) connect触发三次握手的过程,\b这时候有几种结果： 成功 第一个SYN分节没有受到ACK，则重试，重试也失败了，返回ETIMEOUT错误 返回的分节不是ACK，是RST。返回ECONNREFUSED RST出现有三个条件： 目标主机收到SYN分节,但是没有监听这个端口的服务器进程 tcp想取消一个已有的连接 tcp收到的分节不属于这个连接 ICMP路由不可达错误，客户端会重试 3. bind函数int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen) bind函数用于给socket地址赋予一个协议地址(ip+port)服务器程序通常需要使用bind，客户端则由系统分配就好 bind函数常见返回错误是Address aready in use 4. listen函数int listen(int sockfd, int backlog) \u001csocket函数得到的套接字默认是主动套接字，即系统认为它以后是要去做connect发起连接的而listen函数的作用有二： 将主动转被动，告诉系统“我不该主动，我该接受指向这个套接字的请求” \bbacklog指定了内核为这个socket排队的最大连接个数(有的操作系统增加了一个模糊因子，backlog作为一个和最大连接数正相关的值)，内核有两个队列 三次握手的过程： 通常RTT平均在187ms 未完成队列满了对继续过来的请求分节丢弃不处理（因为客户端会重传） 5. accept函数int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen) accept函数会从完成队列头push一个连接，由内核生成一个已连接套接字(connected socket)，一个服务进程通常持有一个listening socket（监听套接字）,n个connect socket（每个客户端一个） 并发服务器基本原理：基础：文件描述符和socket描述符有一个引用计数器，被引用一次则加一，没有引用才会被清理 chapter5:tcp客户／服务程序示例chapter30:客户／服务器程序设计范式 《unix网络编程卷一》《图解tcp/ip》","categories":[],"tags":[{"name":"tcp/ip","slug":"tcp-ip","permalink":"http://lqczzz.github.io/tags/tcp-ip/"}]},{"title":"优秀的博文记录","slug":"优秀的博文记录","date":"2018-10-18T07:46:41.000Z","updated":"2018-10-18T07:47:16.000Z","comments":true,"path":"2018/10/18/优秀的博文记录/","link":"","permalink":"http://lqczzz.github.io/2018/10/18/优秀的博文记录/","excerpt":"","text":"golang优化优化Go的模式","categories":[],"tags":[]},{"title":"pprof性能监控和gc调优","slug":"pprof性能监控和gc调优","date":"2018-10-18T07:15:41.000Z","updated":"2018-10-18T07:40:42.000Z","comments":true,"path":"2018/10/18/pprof性能监控和gc调优/","link":"","permalink":"http://lqczzz.github.io/2018/10/18/pprof性能监控和gc调优/","excerpt":"","text":"参考godoc-DiagnosticsGolang使用pprof监控性能及GC调优[golang]pprof性能分析工具","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://lqczzz.github.io/tags/性能优化/"}]},{"title":"sync.Pool笔记","slug":"sync-Pool笔记","date":"2018-10-18T03:04:01.000Z","updated":"2018-10-18T07:24:13.000Z","comments":true,"path":"2018/10/18/sync-Pool笔记/","link":"","permalink":"http://lqczzz.github.io/2018/10/18/sync-Pool笔记/","excerpt":"","text":"参考1. o语言的官方包sync.Pool的实现原理和适用场景2. github-slab","categories":[],"tags":[{"name":"timeline重构任重道远","slug":"timeline重构任重道远","permalink":"http://lqczzz.github.io/tags/timeline重构任重道远/"}]},{"title":"从golang的fmt包入门手动内存管理","slug":"golang的fmt包入门手动内存管理","date":"2018-10-17T14:01:43.000Z","updated":"2018-10-17T15:05:48.000Z","comments":true,"path":"2018/10/17/golang的fmt包入门手动内存管理/","link":"","permalink":"http://lqczzz.github.io/2018/10/17/golang的fmt包入门手动内存管理/","excerpt":"","text":"矫情的话在做feed流开发的时候，我负责timeline的业务开发，刚开始设计的时候我以为也就是个业务代码开发，能有啥难度。结果开发完了之后，被leader疯狂吐槽。代码组织不好，这些都能通过对业务的深入理解，去重新设计，但是说到一个内存管理的问题，我是完全没想到的，以前没有接触过高并发场景，不知道在高并发场景下，依赖语言自身的gc会导致内存的频繁申请和回收。 痛定几周之后决定思痛，要参考学习优秀的代码于是我想，哪里会有优秀的涉及到内存管理的代码呢！ 官方库！！ 然后想，timeline涉及网络io，io才会有大量的内存分配和回收的场景！！ 直接看net包？太尼玛复杂了ok，看fmt包 fmt包源码摘要和笔记 来自fmt/print.go // Fprintf根据w的不同，调用w的write方法，很容易做到打印日志到不同地方 func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) { p := newPrinter() p.doPrintf(format, a) n, err = w.Write(p.buf) p.free() return } // Printf调用了Fprintf，打印的地方是os.Stdout func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...) } func Sprintf(format string, a ...interface{}) string { p := newPrinter() p.doPrintf(format, a) s := string(p.buf) p.free() return s } 这里至少有三点可以学: 包本身就是模块化的一种方式，对外提供的函数不一定非得属于某个对象 接口作为参数的好处：封装变化 这里，变化指的是[]byte的去向，比如os.Stdout p := newPrinter()这里采用了临时对象池来实现内存的管理 看下去： // pp is used to store a printer&apos;s state and is reused with sync.Pool to avoid allocations. type pp struct { buf buffer // 省略 } var ppFree = sync.Pool{ New: func() interface{} { return new(pp) }, } // newPrinter allocates a new pp struct or grabs a cached one. func newPrinter() *pp { p := ppFree.Get().(*pp) p.panicking = false p.erroring = false p.fmt.init(&amp;p.buf) return p } // free saves used pp structs in ppFree; avoids an allocation per invocation. func (p *pp) free() { p.buf = p.buf[:0] // 清空slice p.arg = nil p.value = reflect.Value{} ppFree.Put(p) // 放回对象池里 } 一个sync.Pool对象就是一组临时对象的集合。Pool是协程安全的。Pool用于存储那些被分配了但是没有被使用，而未来可能会使用的值，以减小垃圾回收的压力。 fmt包总是需要使用一些[]byte之类的对象，golang建立了一个临时对象池，存放着这些对象，如果需要使用一个[]byte，就去Pool里面拿，如果拿不到就分配一份。这比起不停生成新的[]byte，用完了再等待gc回收来要高效得多 sync.Pool测试// 一个[]byte的对象池，每个对象为一个[]byte var bytePool = sync.Pool{ New: func() interface{} { b := make([]byte, 1024) return &amp;b }, } func main() { a := time.Now().Unix() // 不使用对象池 for i := 0; i &lt; 1000000000; i++ { obj := make([]byte, 1024) _ = obj } b := time.Now().Unix() // 使用对象池 for i := 0; i &lt; 1000000000; i++ { obj := bytePool.Get().(*[]byte) _ = obj bytePool.Put(obj) } c := time.Now().Unix() fmt.Println(&quot;without pool &quot;, b-a, &quot;s&quot;) fmt.Println(&quot;with pool &quot;, c-b, &quot;s&quot;) } 来自：go的临时对象池–sync.Pool 测试效果： // 数据量更大更明显 without pool 21 s with pool 16 s the end…","categories":[],"tags":[{"name":"timeline重构任重道远","slug":"timeline重构任重道远","permalink":"http://lqczzz.github.io/tags/timeline重构任重道远/"}]},{"title":"一次goroutine内存泄漏问题定位","slug":"一次goroutine内存泄漏问题定位","date":"2018-10-16T05:38:08.000Z","updated":"2018-10-21T05:57:30.000Z","comments":true,"path":"2018/10/16/一次goroutine内存泄漏问题定位/","link":"","permalink":"http://lqczzz.github.io/2018/10/16/一次goroutine内存泄漏问题定位/","excerpt":"","text":"定位过程问题： Dump goroutines: ps aux | grep &apos;content_svr&apos; #43 kill -USR2 43 比较两小时间的Diff：两小时前: $ grep &apos;cron/hashtag_suggestion&apos; /proc/43/fd/1 1 $ grep &apos;producer&apos; /proc/43/fd1 53 两小时后: $ grep &apos;cron/hashtag_suggestion&apos; /proc/43/fd/1 41 $ grep &apos;producer&apos; /proc/43/fd1 221 问题代码// 简化了业务逻辑 type Cron struct{ ch1 chan []int ch2 chan []int } func (cron *Cron)start() { timer := time.NewTicker(cron.taskDuration) for { select { case &lt;-timer.C: cron.doCron() } } } func (cron *Cron)doCron() { cron.step1() cron.step2() cron.step3() } func (cron *Cron)step1() { go func(){ cron.ch1 &lt;- []int{100} // 注意这里没有关闭ch1，导致下面的goroutine一直没有关闭 }() } func (cron *Cron)step2() { go func(){ for item := range cron.ch1 { _ = item cron.ch2 &lt;- []int{200} // 注意这里没有关闭ch2，导致下面的goroutine一直没有关闭 } }() } func (cron *Cron)step3() { go func(){ for item := range cron.ch2 { _ = item } }() } 纠正// 1. 每次创建goroutine时候创建channel // 2. 每次使用完channel，close channel，退出goroutine type Cron struct{ ch1 chan []int ch2 chan []int } const ( concurrency = 100 ) func (cron *Cron)start() { timer := time.NewTicker(cron.taskDuration) for { select { case &lt;-timer.C: cron.doCron() } } } func (cron *Cron)doCron() { cron.ch1 = make(chan []int, concurrency) // fixed cron.ch2 = make(chan []int, concurrency) // fixed cron.step1() cron.step2() cron.step3() } func (cron *Cron)step1() { go func(){ cron.ch1 &lt;- []int{100} close(ch1) // fixed }() } func (cron *Cron)step2() { go func(){ for item := range cron.ch1 { _ = item cron.ch2 &lt;- []int{200} close(ch2) // fixed } }() } func (cron *Cron)step3() { go func(){ for item := range cron.ch2 { _ = item } }() }","categories":[],"tags":[]},{"title":"知识管理","slug":"知识管理","date":"2018-10-14T03:06:31.000Z","updated":"2018-10-14T11:48:01.000Z","comments":true,"path":"2018/10/14/知识管理/","link":"","permalink":"http://lqczzz.github.io/2018/10/14/知识管理/","excerpt":"","text":"为什么这样分类笔记用于我对知识的掌握，工作快两年了我才发现了知识的几个特点： 很多知识机靠记忆是没办法持久化存储的 比如前端vue框架，我用了大半年了，发现才转后台3个月，vue的很多东西就忘的差不多了 比如spring相关的框架，从大学开始使用到现在，断断续续，每次重新使用都得重新学习一遍，虽然每次学习的时间会越来越缩短。 比如开发工具，使用的编辑器的快捷键的使用等，都是很容易遗忘但是有没必要刻意去记住的 很多知识是细枝末节的 比如\b某种框架，框架其实是一种架构良好的工具，提供了某种不变的东西，让你快速实现某种变化，来适应不同的业务场景。比如spring系的的框架，模版设计模式就很常用，你只要继承某种基类，然后实现特定的抽象函数（钩子函数），就能完成一个不同的功能，而前端框架vue的组件化就是最明显的模板模式的应用。框架是一种工具，工具的实现和接口都是细枝末节的，就算完全忘记了，只要拿上一个上午的时间甚者更短，就能再次掌握起来了。 在华为曾做过一个项目，后台开始是用node实现的，领导觉得node不安全，于是让我们用java重构，并且做好服务化，我们把微服务当作银弹，结果重构之后更加难部署了，项目的规模也没有达到必须使用服务化的必要。这就是锤子理论，拿起锤子，觉得什么都是钉子。 很多知识是可以进行类比的 比如web框架，不管是node的koa，python的flask还是golang的gin，都是有很多通用的概念，常用的套路，相同的业务场景和解决方案，举一反三对掌握新的工具是很有用的 很多知识是可以快速掌握和应用的 分类的策略 入门类：对概念和基本流程有一个基本的认识 笔记类： 常用的用法的记录 原理类： 对入门类有更详细的认识 实战类： 具体场景下的使用","categories":[],"tags":[]},{"title":"elasticSearch学习笔记","slug":"elasticSearch学习笔记","date":"2018-10-13T14:29:32.000Z","updated":"2018-10-17T05:17:10.000Z","comments":true,"path":"2018/10/13/elasticSearch学习笔记/","link":"","permalink":"http://lqczzz.github.io/2018/10/13/elasticSearch学习笔记/","excerpt":"","text":"elasticSearch入门最近在项目中遇到了需要搜索引擎的场景，对用户输入进行自动推荐和补全，elasticSearch是\b开源的搜索引引擎，入门使用也很简单。 怎么入门： 类比入门：类比一个熟悉的知识点，知识迁移\b会更容易 简单的事例入门：动手进行简单的一个demo感受一下流程 入门1.安装es前置条件：mac环境(其他环境自行google)，brew工具安装好了，java环境安装好了 步骤： 安装es： brew install elasticsearch es服务端会被安装 安装kibana： brew install kibana kibana可以理解为图形化的es客户端 启动es：brew services start elasticsearch 启动kibana：brew services start kibana 安装es成功之后访问http://localhost:9200/可以获得es的状态信息安装kibana成功之后访问http://localhost:5601/app/kibana#/dev_tools/console?_g=()可以对es进行操作 2.自动补全// hashtag { id, name, score, // weight } mappings &amp; analysizerPUT feed_id { &quot;mappings&quot;: { &quot;hashtag&quot;: { &quot;properties&quot;: { &quot;name&quot;: { &quot;type&quot;: &quot;completion&quot; } } } } } 添加数据POST feed_id/hashtag { &quot;name&quot;: { &quot;input&quot;: [&quot;hashtag name&quot;], &quot;weight&quot;: 2 } } POST feed_id/hashtag/3 { &quot;name&quot;: { &quot;input&quot;: [&quot;hashtag name2&quot;], &quot;weight&quot;: 3 } } POST feed_id/hashtag/4 { &quot;name&quot;: { &quot;input&quot;: [&quot;ashtag name2&quot;], &quot;weight&quot;: 4 } } POST feed_id/hashtag/5 { &quot;name&quot;: { &quot;input&quot;: [&quot;shtag name2&quot;], &quot;weight&quot;: 5 } } POST feed_id/hashtag/6 { &quot;name&quot;: { &quot;input&quot;: [&quot;htag name2&quot;], &quot;weight&quot;: 6 } } POST feed_id/hashtag/7 { &quot;name&quot;: { &quot;input&quot;: [&quot;爱我中华&quot;], &quot;weight&quot;: 6 } } POST feed_id/hashtag/8 { &quot;name&quot;: { &quot;input&quot;: [&quot;爱你中华&quot;], &quot;weight&quot;: 6 } } POST feed_id/hashtag/9 { &quot;name&quot;: { &quot;input&quot;: [&quot;爱你&quot;], &quot;weight&quot;: 6 } } 查询数据POST feed_id/_search?pretty { &quot;suggest&quot;: { &quot;hashtag-suggest&quot;: { &quot;prefix&quot;: &quot;h&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;name&quot; } } } } 基本概念摘抄自elasticsearch-definitive-guide-cn 参考：","categories":[],"tags":[]},{"title":"记timeline重构","slug":"记timeline重构","date":"2018-10-12T22:28:45.000Z","updated":"2018-10-18T07:24:50.000Z","comments":true,"path":"2018/10/13/记timeline重构/","link":"","permalink":"http://lqczzz.github.io/2018/10/13/记timeline重构/","excerpt":"","text":"timeline重构任重道远 所以，接下来很多笔记大概都会和timeline相关 内存管理: 周四周五 golang性能分析工具：周末 pprof go bentch test","categories":[],"tags":[{"name":"timeline重构任重道远","slug":"timeline重构任重道远","permalink":"http://lqczzz.github.io/tags/timeline重构任重道远/"}]},{"title":"golang并发学习笔记","slug":"golang并发","date":"2018-10-12T22:28:05.000Z","updated":"2018-10-14T16:03:46.000Z","comments":true,"path":"2018/10/13/golang并发/","link":"","permalink":"http://lqczzz.github.io/2018/10/13/golang并发/","excerpt":"","text":"golang的并发模型叫做CSP（communicating sequential process），称为通信顺序进程模型，模型由独立并发执行的实体组成（go块），模型之间的通信通过channel来实现。因此，golang的并发模型哲学是：万物皆通信！！golang的核心概念主要是： channel go块 channel channel可以单独创建，在进程之间传递 channel是线程安全队列，任何持有channel引用的任务(go块)都可以读写channel channel默认是无缓冲区的，也就是channel本身是同步的，一端写数据操作必然会阻塞直到channel的数据被别的地方读取 channel可以关闭，向关闭的channel读数据会读到的默认值，向关闭的channel写数据会导致panic！！ func main() { ch := make(chan int) go func() { ch &lt;- 20 close(ch) ch &lt;- 30 //panic: send on closed channel }() println(&lt;-ch) // 20 println(&lt;-ch) // 0(默认值) } 有缓冲区的channel，根据缓冲区已满时候的策略，可以分为 阻塞型：写入阻塞 弃用新值：新值写入被抛弃 移除旧值：太旧的数据被channel抛弃 channel和\b队列很像 在 golang里，channel可以用 for i := range channelName {}\b循环获取channel信息 goroutine线程模型的缺点java和c++的并发模型都是线程模型，它的好处是直接对硬件的抽象，大多数语言，包括python，它的线程模型都是操作系统线程，但是坏处是使用复杂。 但是线程模型有三个危害 竞态条件 死锁 内存可见性问题引用自《七周七并发编程模型》 public class Test { static boolean ready = false; // 竞态条件一：共享变量 static int data = 0 static Thread t1 = new Thread() { public void run() { data = 10; // 竞态条件二：会有并行实体(线程)修改变量 ready = true; } }; static Thread t2 = new Thread() { public void run() { if (ready) { // 竞态条件三：一个未处理完成另外一个处理可能会介入 System.out.Println(&quot;data is :&quot; + data) } else { System.out.Println(&quot;no data&quot;) } } }; public static void main(String[] args) throw InterruptedException{ t1.start(); t2.start(); t1.join(); t2.join(); } } 尽管线程模型问题很多，但是线程模型是其他模型的基础，比如nodejs的\b异步io模型，本质上也是基于线程池技术实现的，java的nio底层实现也是基于线程池。 线程池是多线程模型的改良，线程的启动和运行都有一定的开销，为了避免直接创建线程，才有了线程池，线程池方便了线程的复用，但是涉及线程通信的时候，如果线程被阻塞，那这个线程的资源永远都被占用者，线程池就显得鸡肋了。nodejs的决绝方法是限制程序员的代码风格，使之变成事件驱动的形式。 goroutine调度机制和状态机所谓事件驱动是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。 node.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（ emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束，因此，node.js 是单线程，异步非阻塞 node的这种方式有几个问题： CPU密集型任务存在短板 无法利用CPU的多核 代码变得难以阅读 回调函数保存数据需要经常用到全局变量 golang本质上也是使用了事件驱动的机制，但是这个过程对我们是透明的，主要解决了第三个问题，原理是把每个go块(go func(){}())当层成了一个状态机，当go块从channel里读写，遇到阻塞的时候，go块进入暂停状态，让出线程控制权，代码可以继续进行的时候，状态扭转，go块继续运行(可能不在原来的线程上了) goroutine和线程 每个os线程有一个固定大小的栈内存（通常2MB） goroutine的栈空间大小不固定，开始通常是2KB，按需扩展，最大可达1GB go运行时候有自己的goroutine调度算法，称为m：n调度，m个goroutine运行在n个线程上 同是调度算法，为何go的调度算法如此优秀？ 其实不然，和操作系统线程调度器对比，主要不同在于： os内核调度上下文切换开销大，go调度器只需要调度一个go程序自己的goroutine，更容易hold住 os调度是硬件时钟中断触发的，goroutine调度的触发是channel读写阻塞或者time.Sleep()来实现的，因此不需要切换到内核态。 goroutine没有标识，线程是有自己的标识的，因此可以方便的实现\b一个线程局部变量(map[thread_symbol]object),在web服务器上，线程局部变量通常会被用来存储http请求信息。在goroutine上没有这种机制，鼓励更简单的编程风格。——《go程序设计语言》","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"http://lqczzz.github.io/tags/golang/"},{"name":"并发","slug":"并发","permalink":"http://lqczzz.github.io/tags/并发/"}]}]}