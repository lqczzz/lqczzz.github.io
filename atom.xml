<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lqczzz.github.io/"/>
  <updated>2018-10-14T11:48:01.000Z</updated>
  <id>http://lqczzz.github.io/</id>
  
  <author>
    <name>lqczzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知识管理</title>
    <link href="http://lqczzz.github.io/2018/10/14/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    <id>http://lqczzz.github.io/2018/10/14/知识管理/</id>
    <published>2018-10-14T03:06:31.000Z</published>
    <updated>2018-10-14T11:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么这样分类"><a href="#为什么这样分类" class="headerlink" title="为什么这样分类"></a>为什么这样分类</h2><p>笔记用于我对知识的掌握，工作快两年了我才发现了知识的几个特点：</p><ol><li><p>很多知识机靠记忆是没办法持久化存储的</p><ul><li>比如前端vue框架，我用了大半年了，发现才转后台3个月，vue的很多东西就忘的差不多了</li><li>比如spring相关的框架，从大学开始使用到现在，断断续续，每次重新使用都得重新学习一遍，虽然每次学习的时间会越来越缩短。</li><li>比如开发工具，使用的编辑器的快捷键的使用等，都是很容易遗忘但是有没必要刻意去记住的</li></ul></li><li><p>很多知识是细枝末节的</p><ul><li><p>比如某种框架，框架其实是一种架构良好的工具，提供了某种不变的东西，让你快速实现某种变化，来适应不同的业务场景。比如spring系的的框架，模版设计模式就很常用，你只要继承某种基类，然后实现特定的抽象函数（钩子函数），就能完成一个不同的功能，而前端框架vue的组件化就是最明显的模板模式的应用。框架是一种工具，工具的实现和接口都是细枝末节的，就算完全忘记了，只要拿上一个上午的时间甚者更短，就能再次掌握起来了。</p></li><li><p>在华为曾做过一个项目，后台开始是用node实现的，领导觉得node不安全，于是让我们用java重构，并且做好服务化，我们把微服务当作银弹，结果重构之后更加难部署了，项目的规模也没有达到必须使用服务化的必要。这就是锤子理论，拿起锤子，觉得什么都是钉子。</p></li></ul></li></ol><ol><li><p>很多知识是可以进行类比的</p><ul><li>比如web框架，不管是node的koa，python的flask还是golang的gin，都是有很多通用的概念，常用的套路，相同的业务场景和解决方案，举一反三对掌握新的工具是很有用的</li></ul></li><li><p>很多知识是可以快速掌握和应用的</p></li></ol><h2 id="分类的策略"><a href="#分类的策略" class="headerlink" title="分类的策略"></a>分类的策略</h2><ol><li>入门类：对概念和基本流程有一个基本的认识</li><li>笔记类：<ul><li>常用的用法的记录</li></ul></li><li>原理类：<ul><li>对入门类有更详细的认识</li></ul></li><li>实战类：<ul><li>具体场景下的使用</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么这样分类&quot;&gt;&lt;a href=&quot;#为什么这样分类&quot; class=&quot;headerlink&quot; title=&quot;为什么这样分类&quot;&gt;&lt;/a&gt;为什么这样分类&lt;/h2&gt;&lt;p&gt;笔记用于我对知识的掌握，工作快两年了我才发现了知识的几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;很多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>elasticSearch学习笔记</title>
    <link href="http://lqczzz.github.io/2018/10/13/elasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://lqczzz.github.io/2018/10/13/elasticSearch学习笔记/</id>
    <published>2018-10-13T14:29:32.000Z</published>
    <updated>2018-10-13T15:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="elasticSearch入门"><a href="#elasticSearch入门" class="headerlink" title="elasticSearch入门"></a>elasticSearch入门</h1><p>最近在项目中遇到了需要搜索引擎的场景，对用户输入进行自动推荐和补全，elasticSearch是开源的搜索引引擎，入门使用也很简单。</p><p>怎么入门：</p><ol><li>类比入门：类比一个熟悉的知识点，知识迁移会更容易</li><li>简单的事例入门：动手进行简单的一个demo感受一下流程</li></ol><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="1-安装es"><a href="#1-安装es" class="headerlink" title="1.安装es"></a>1.安装es</h3><p>前置条件：mac环境(其他环境自行google)，brew工具安装好了，java环境安装好了</p><p>步骤：</p><ol><li>安装es：<ul><li>brew install elasticsearch</li><li>es服务端会被安装</li></ul></li><li>安装kibana：<ul><li>brew install kibana</li><li>kibana可以理解为图形化的es客户端</li></ul></li><li>启动es：brew services start elasticsearch</li></ol><p>安装es成功之后访问<code>http://localhost:9200/</code>可以获得es的状态信息<br>安装kibana成功之后访问<code>http://localhost:5601/app/kibana#/dev_tools/console?_g=()</code>可以对es进行操作</p><h3 id="2-自动补全"><a href="#2-自动补全" class="headerlink" title="2.自动补全"></a>2.自动补全</h3><pre><code>// hashtag{    id,    name,    score, // weight}</code></pre><h4 id="mappings-amp-analysizer"><a href="#mappings-amp-analysizer" class="headerlink" title="mappings &amp; analysizer"></a>mappings &amp; analysizer</h4><pre><code>PUT feed_id{    &quot;mappings&quot;: {        &quot;hashtag&quot;: {            &quot;properties&quot;: {                &quot;name&quot;: {                    &quot;type&quot;: &quot;completion&quot;                 }            }        }    }}</code></pre><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><pre><code>POST feed_id/hashtag{    &quot;name&quot;: {        &quot;input&quot;: [&quot;hashtag name&quot;],        &quot;weight&quot;: 2    }}POST feed_id/hashtag/3{    &quot;name&quot;: {        &quot;input&quot;: [&quot;hashtag name2&quot;],        &quot;weight&quot;: 3    }}POST feed_id/hashtag/4{    &quot;name&quot;: {        &quot;input&quot;: [&quot;ashtag name2&quot;],        &quot;weight&quot;: 4    }}POST feed_id/hashtag/5{    &quot;name&quot;: {        &quot;input&quot;: [&quot;shtag name2&quot;],        &quot;weight&quot;: 5    }}POST feed_id/hashtag/6{    &quot;name&quot;: {        &quot;input&quot;: [&quot;htag name2&quot;],        &quot;weight&quot;: 6    }}POST feed_id/hashtag/7{    &quot;name&quot;: {        &quot;input&quot;: [&quot;爱我中华&quot;],        &quot;weight&quot;: 6    }}POST feed_id/hashtag/8{    &quot;name&quot;: {        &quot;input&quot;: [&quot;爱你中华&quot;],        &quot;weight&quot;: 6    }}POST feed_id/hashtag/9{    &quot;name&quot;: {        &quot;input&quot;: [&quot;爱你&quot;],        &quot;weight&quot;: 6    }}</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>POST feed_id/_search?pretty{    &quot;suggest&quot;: {        &quot;hashtag-suggest&quot;: {            &quot;prefix&quot;: &quot;h&quot;,            &quot;completion&quot;: {                &quot;field&quot;: &quot;name&quot;            }        }    }}</code></pre><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>摘抄自<a href="ttps://github.com/looly/elasticsearch-definitive-guide-cn" target="_blank" rel="noopener">elasticsearch-definitive-guide-cn</a></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;elasticSearch入门&quot;&gt;&lt;a href=&quot;#elasticSearch入门&quot; class=&quot;headerlink&quot; title=&quot;elasticSearch入门&quot;&gt;&lt;/a&gt;elasticSearch入门&lt;/h1&gt;&lt;p&gt;最近在项目中遇到了需要搜索引擎的场景
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记timeline重构</title>
    <link href="http://lqczzz.github.io/2018/10/13/%E8%AE%B0timeline%E9%87%8D%E6%9E%84/"/>
    <id>http://lqczzz.github.io/2018/10/13/记timeline重构/</id>
    <published>2018-10-12T22:28:45.000Z</published>
    <updated>2018-10-14T03:15:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang并发</title>
    <link href="http://lqczzz.github.io/2018/10/13/golang%E5%B9%B6%E5%8F%91/"/>
    <id>http://lqczzz.github.io/2018/10/13/golang并发/</id>
    <published>2018-10-12T22:28:05.000Z</published>
    <updated>2018-10-14T14:56:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang的并发模型叫做CSP（communicating sequential process），称为通信顺序进程模型，模型由独立并发执行的实体组成（go块），模型之间的通信通过channel来实现。因此，golang的并发模型哲学是：万物皆通信！！golang的核心概念主要是：</p><ol><li>channel</li><li>go块</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><ul><li>channel可以单独创建，在进程之间传递</li><li>channel是<code>线程安全</code>队列，任何持有channel引用的任务(go块)都可以读写channel</li><li>channel默认是无缓冲区的，也就是channel本身是同步的，一端写数据操作必然会阻塞直到channel的数据被别的地方读取</li><li><p>channel可以关闭，向关闭的channel读数据会读到的默认值，向关闭的channel写数据会导致panic！！</p><pre><code>func main() {    ch := make(chan int)    go func() {        ch &lt;- 20        close(ch)        ch &lt;- 30 //panic: send on closed channel    }()    println(&lt;-ch) // 20    println(&lt;-ch) // 0(默认值)}</code></pre></li><li><p>有缓冲区的channel，根据缓冲区已满时候的策略，可以分为</p><ul><li>阻塞型：写入阻塞</li><li>弃用新值：新值写入被抛弃</li><li>移除旧值：太旧的数据被channel抛弃</li></ul></li></ul><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>java和c++的并发模型都是线程模型，它的好处是直接对硬件的抽象，大多数语言，包括python，它的线程模型都是操作系统线程，但是坏处是使用复杂。</p><p>但是线程模型有三个危害</p><blockquote><ol><li>竞态条件</li><li>死锁</li><li>内存可见性问题<br>引用自《七周七并发编程模型》</li></ol></blockquote><pre><code>public class Test {    static boolean ready = false;   // 竞态条件一：共享变量    static int data = 0    static Thread t1 = new Thread() {        public void run() {            data = 10;  // 竞态条件二：会有并行实体(线程)修改变量            ready = true;        }    };    static Thread t2 = new Thread() {        public void run() {            if (ready) {    // 竞态条件三：一个未处理完成另外一个处理可能会介入                System.out.Println(&quot;data is :&quot; + data)            } else {                System.out.Println(&quot;no data&quot;)            }        }    };    public static void main(String[] args) throw InterruptedException{        t1.start();        t2.start();        t1.join();        t2.join();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;golang的并发模型叫做CSP（communicating sequential process），称为通信顺序进程模型，模型由独立并发执行的实体组成（go块），模型之间的通信通过channel来实现。因此，golang的并发模型哲学是：万物皆通信！！golang的核心概
      
    
    </summary>
    
    
      <category term="golang" scheme="http://lqczzz.github.io/tags/golang/"/>
    
      <category term="并发" scheme="http://lqczzz.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
