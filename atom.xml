<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lqczzz.github.io/"/>
  <updated>2020-08-11T06:02:24.117Z</updated>
  <id>http://lqczzz.github.io/</id>
  
  <author>
    <name>lqczzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络编程的那些事</title>
    <link href="http://lqczzz.github.io/2020/08/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://lqczzz.github.io/2020/08/11/网络编程的那些事/</id>
    <published>2020-08-11T05:36:38.000Z</published>
    <updated>2020-08-11T06:02:24.117Z</updated>
    
    <content type="html"><![CDATA[<h2>导读</h2><p>工作三年，接触过java，python，golang的一些常用的web框架，网络编程库，并发编程模式之后，渐渐开始掌握了网络编程的一些核心的东西：</p><ul><li>socket编程</li><li>io模型</li><li>并发模型</li></ul><p>其中<code>超时</code>是在不可靠的网络环境中很重要的一个手段，用于判定失效(尽管这种判定也不是那么的完美)</p><h4>怎么读</h4><p>文章分成两部分</p><ul><li>第一部分，主要简单罗列了一些网络编程的核心知识，不管什么框架，涉及到的核心的领域知识都在里面。希望文中的每一张图都能够充分理解</li><li>第二部分，主要介绍了golang标准的网络库的并发编程实现，用精妙的奇技淫巧来实现一个简单但是很高性能的库，足以把上述所有的知识贯穿一体。</li></ul><h2>[A] 网络编程基础知识</h2><h3>[B] socket编程</h3><h4>[C] 调用过程</h4><p><img src="/images/a_story_of_net/image-20200807114448022.png" alt="image-20200807114448022"></p><p><img src="/images/a_story_of_net/image-20200811114808497.png" alt="image-20200811114808497"></p><p><img src="/images/a_story_of_net/image-20200811114824738.png" alt="image-20200811114824738"></p><h5>[D]说明</h5><h6>[E]time_wait</h6><p>可靠的全双工断连，确保ack能到达服务端（否则服务端会超时重发fin）</p><h6>[E]RST</h6><p>connection发起三次握手会有几种异常状态：</p><p>1）服务器不可达：syn分节发出去，超时没有收到响应分节，退避重试，返回ETIMEDOUT</p><p>2）服务端可达，但是没有服务进程监听该端口，收到RST分节而不是ACK分节</p><p>另外一种情况是(握手成功，但是accept之前收到一个RST分节，有些操作系统会向用户进程抛出错误，有的则对用户进程无感知)：</p><p><img src="/images/a_story_of_net/image-20200811120530133.png" alt="image-20200811120530133"></p><h6>[E]4次挥手过程的错误(服务端进程崩溃啥的)</h6><p><img src="/images/a_story_of_net/image-20200811121902826.png" alt="image-20200811121902826"></p><h6>[E]查看链接状态的工具</h6><ul><li><p>netstat</p><p>netstat -a</p></li></ul><h5>[D]系统调用说明</h5><h6>[E]Bind</h6><p>绑定端口（默认为主动套接字，端口随机分配，listen之后主动套接字变成被动套接字，端口需要指定）</p><h6>[E]listen</h6><p><img src="/images/a_story_of_net/image-20200807114735093.png" alt="image-20200807114735093"></p><p><img src="/images/a_story_of_net/image-20200807114751286.png" alt="image-20200807114751286"></p><h6>[E]accept</h6><p>同步accept：线程进入休眠</p><p>异步accept：立即返回错误</p><p><img src="/images/a_story_of_net/image-20200807113106672.png" alt="image-20200807113106672"></p><h3>[B]io</h3><h4>[C]linux文件系统</h4><p><img src="https://www.thomas-krenn.com/de/wikiDE/images/e/e0/Linux-storage-stack-diagram_v4.10.png" alt="linux文件系统栈参考"></p><p><img src="/images/a_story_of_net/image-20200807120935597.png" alt="image-20200807120935597"></p><p>操作系统上的 I/O 是用户空间和内核空间的数据交互，因此 I/O 操作通常包含以下两个步骤：</p><ol><li>等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&gt; 读取/写入到内核缓冲区</li><li>从内核缓冲区复制数据 –&gt; 用户空间(读)/从用户空间复制数据 -&gt; 内核缓冲区(写)</li></ol><h4>[C]io模型</h4><p>在神作《UNIX 网络编程》里，总结归纳了 5 种 I/O 模型，包括同步和异步 I/O：</p><ul><li>阻塞 I/O (Blocking I/O)</li><li>非阻塞 I/O (Nonblocking I/O)</li><li>I/O 多路复用 (I/O multiplexing)</li><li>信号驱动 I/O (Signal driven I/O)</li><li>异步 I/O (Asynchronous I/O)</li></ul><h5>[D] 阻塞io</h5><p><img src="/images/a_story_of_net/image-20200807112737727.png" alt="image-20200807112737727"></p><ul><li>实现简单</li><li>等待io的时候，线程需要陷入内核进入休眠，切换消耗大</li></ul><h5>[D] 非阻塞io</h5><p><img src="/images/a_story_of_net/image-20200807112804026.png" alt="image-20200807112804026"></p><ul><li>不阻塞后续操作</li><li>轮询的方式来查看是否有数据ready了，消耗cpu</li></ul><h5>[D] io多路复用</h5><p><img src="/images/a_story_of_net/image-20200807112832933.png" alt="image-20200807112832933"></p><ul><li>同时监听多路io，提高效率</li></ul><h5>[D] 信号驱动io</h5><p><img src="/images/a_story_of_net/image-20200807112846815.png" alt="image-20200807112846815"></p><h5>[D] 异步io</h5><p><img src="/images/a_story_of_net/image-20200807112900566.png" alt="image-20200807112900566"></p><p><img src="/images/a_story_of_net/image-20200807112913126.png" alt="image-20200807112913126"></p><h3>[B] 常用并发编程模型</h3><h4>[C] 常用并发编程模型</h4><h5>[D] 多进程</h5><h5>[D] 多线程</h5><h5>[D] 协程</h5><h4>[C] G-P-M 模型</h4><p><img src="/images/a_story_of_net/image-20200807133514037.png" alt="image-20200807133514037"></p><ul><li>每个 P 维护一个 G 的本地队列；</li><li>当一个 G 被创建出来，或者变为可执行状态时，就把他放到 P 的可执行队列中；</li><li>当一个 G 在 M 里执行结束后，P 会从队列中把该 G 取出；如果此时 P 的队列为空，即没有其他 G 可以执行， M 就随机选择另外一个 P，从其可执行的 G 队列中取走一半。</li></ul><blockquote><p>goroutine 的栈采取了动态扩容方式， 初始时仅为 2KB，随着任务执行按需增长，最大可达 1GB（64 位机器最大是 1G，32 位机器最大是 256M），且完全由 golang 自己的调度器 <strong>Go Scheduler</strong> 来调度。此外，GC 还会周期性地将不再使用的内存回收，收缩栈空间。 因此，Go 程序可以同时并发成千上万个 goroutine 是得益于它强劲的调度器和高效的内存模型。</p></blockquote><h4>[C] 客户端/服务端程序设计范式</h4><h5>[D] 从请求生命周期看</h5><p><img src="/images/a_story_of_net/image-20200807154036221.png" alt="image-20200807154036221"></p><h5>[D] 从并发单元角度</h5><ul><li>多进程<ul><li>来一个请求，排队处理：串行</li><li>来一个请求，fork一个进程处理：并行，并发消耗大，fork消耗性能</li><li>预先fork一批进程，“进程池” - apache？？</li></ul></li><li><h2>多线程</h2></li><li><h2>routine</h2></li></ul><h4>[C] reactor模式</h4><p>本质：nonblockio + 多路复用</p><h5>[D] 单reactor单线程</h5><p><img src="/images/a_story_of_net/image-20200807165308347.png" alt="image-20200807165308347"></p><p>eg：redis</p><h5>[D] 单 reactor多线程</h5><p><img src="/images/a_story_of_net/image-20200807165359811.png" alt="image-20200807165359811"></p><h5>[D] 主从reactor</h5><p><img src="/images/a_story_of_net/image-20200807165611483.png" alt="image-20200807165611483"></p><p><img src="/images/a_story_of_net/image-20200807165648588.png" alt="image-20200807165648588"></p><h2>[A] golang net原理和包源码导读</h2><h3>[B] 一个标准go tcp服务程序</h3><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8888"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"listen error: "</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">conn, err := listen.Accept()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"accept error: "</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start a new goroutine to handle the new connection</span></span><br><span class="line"><span class="keyword">go</span> HandleConn(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">packet := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有可读数据，也就是读 buffer 为空，则阻塞</span></span><br><span class="line">_, _ = conn.Read(packet)</span><br><span class="line"><span class="comment">// 同理，不可写则阻塞</span></span><br><span class="line">_, _ = conn.Write(packet)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8888"</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listen.Accept()</span><br><span class="line">      _, _ = conn.Read([]<span class="keyword">byte</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>[B] 核心原理</h3><ol><li>非阻塞io(从操作系统视角看)</li><li>epoll的io多路复用</li><li>runtime的goroutine调度把非阻塞io“转化”为阻塞io（从开发者/应用视角看）<ol><li>通过gopark把读取/写 io操作未完成的goroutine挂起休眠</li><li>go runtime在调度goroutine &amp;&amp; daemon线程定期 两个时间去轮询看epoll是否有ready的文件描述符，有则唤醒相应的goroutine</li></ol></li></ol><blockquote><p>Go 原生网络模型（基于 netpoll）编写的一个 TCP server，模式是 <code>goroutine-per-connection</code> ，在这种模式下，开发者使用的是同步的模式去编写异步的逻辑而且对于开发者来说 I/O 是否阻塞是无感知的，也就是说开发者无需考虑 goroutines 甚至更底层的线程、进程的调度和上下文切换。而 Go netpoll 最底层的事件驱动技术肯定是基于 epoll/kqueue/iocp 这一类的 I/O 事件驱动技术，只不过是把这些调度和上下文切换的工作转移到了 runtime 的 Go scheduler，让它来负责调度 goroutines，从而极大地降低了程序员的心智负担！</p><p>Go netpoll 通过在底层对 epoll/kqueue/iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 netFD 为中心实现。netFD 与底层 PollDesc 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时，就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 gopark 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll/kqueue/iocp 等事件驱动机制。</p></blockquote><h3>[B] 代码调用时序</h3><p><img src="/images/a_story_of_net/net.png" alt=""></p><h4>[C] 核心对象</h4><h5>[D] netFD</h5><p><code>net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)</code> 方法返回了一个 *TCPListener，它是一个实现了 <code>net.Listener</code> 接口的 struct，而通过 <code>listener.Accept()</code> 接收的新连接 *TCPConn 则是一个实现了 <code>net.Conn</code> 接口的 struct，它内嵌了 <code>net.conn</code> struct。仔细阅读上面的源码可以发现，不管是 Listener 的 Accept 还是 Conn 的 Read/Write 方法，都是基于一个 <code>netFD</code> 的数据结构的操作， <code>netFD</code> 是一个网络描述符，类似于 Linux 的文件描述符的概念，netFD 中包含一个 poll.FD 数据结构</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">pfd poll.FD</span><br><span class="line"></span><br><span class="line"><span class="comment">// immutable until Close</span></span><br><span class="line">family      <span class="keyword">int</span></span><br><span class="line">sotype      <span class="keyword">int</span></span><br><span class="line">isConnected <span class="keyword">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">net         <span class="keyword">string</span></span><br><span class="line">laddr       Addr</span><br><span class="line">raddr       Addr</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5>[D] poll.FD</h5><p>poll.FD 中包含两个重要的数据结构 Sysfd 和 pollDesc，前者是真正的系统文件描述符，后者对是底层事件驱动的封装，所有的读写超时等操作都是通过调用后者的对应方法实现的。</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">fdmu fdMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">Sysfd <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I/O poller.</span></span><br><span class="line">pd pollDesc</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writev cache.</span></span><br><span class="line">iovecs *[]syscall.Iovec</span><br><span class="line"></span><br><span class="line"><span class="comment">// Semaphore signaled when file is closed.</span></span><br><span class="line">csema <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-zero if this file has been set to blocking mode.</span></span><br><span class="line">isBlocking <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line"><span class="comment">// packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line">IsStream <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line"><span class="comment">// message based socket connection.</span></span><br><span class="line">ZeroReadIsEOF <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether this is a file rather than a network socket.</span></span><br><span class="line">isFile <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">runtimeCtx <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>netpoll 是如何通过 park goroutine 从而达到阻塞 Accept/Read/Write 的效果,通过调用 gopark，goroutine 会被放置在某个等待队列中(如 channel 的 waitq ，此时 G 的状态由 <code>_Grunning</code> 为 <code>_Gwaitting</code> )</p><p>当 I/O 事件发生之后，netpoll 是通过什么方式唤醒那些在 I/O wait 的 goroutine 的？答案是通过 <code>epoll_wait</code> ，在 Go 源码中的 <code>src/runtime/netpoll_epoll.go</code> 文件中有一个 <code>func netpoll(block bool) gList</code> 方法，它会内部调用 <code>epoll_wait</code> 获取就绪的 fd 列表，<strong>并将每个 fd 对应的 goroutine 添加到链表返回</strong></p><h5>[D] pollDesc</h5><p>具体的定义是在 <code>runtime.pollDesc</code> 这里</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network poller descriptor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// No heap pointers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">link *pollDesc <span class="comment">// in pollcache, protected by pollcache.lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.</span></span><br><span class="line"><span class="comment">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.</span></span><br><span class="line"><span class="comment">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)</span></span><br><span class="line"><span class="comment">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated</span></span><br><span class="line"><span class="comment">// in a lock-free way by all operations.</span></span><br><span class="line"><span class="comment">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),</span></span><br><span class="line"><span class="comment">// that will blow up when GC starts moving objects.</span></span><br><span class="line">lock    mutex <span class="comment">// protects the following fields</span></span><br><span class="line">fd      <span class="keyword">uintptr</span></span><br><span class="line">closing <span class="keyword">bool</span></span><br><span class="line">everr   <span class="keyword">bool</span>    <span class="comment">// marks event scanning error happened</span></span><br><span class="line">user    <span class="keyword">uint32</span>  <span class="comment">// user settable cookie</span></span><br><span class="line">rseq    <span class="keyword">uintptr</span> <span class="comment">// protects from stale read timers</span></span><br><span class="line">rg      <span class="keyword">uintptr</span> <span class="comment">// pdReady, pdWait, G waiting for read or nil</span></span><br><span class="line">rt      timer   <span class="comment">// read deadline timer (set if rt.f != nil)</span></span><br><span class="line">rd      <span class="keyword">int64</span>   <span class="comment">// read deadline</span></span><br><span class="line">wseq    <span class="keyword">uintptr</span> <span class="comment">// protects from stale write timers</span></span><br><span class="line">wg      <span class="keyword">uintptr</span> <span class="comment">// pdReady, pdWait, G waiting for write or nil</span></span><br><span class="line">wt      timer   <span class="comment">// write deadline timer</span></span><br><span class="line">wd      <span class="keyword">int64</span>   <span class="comment">// write deadline</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>[C] golang对epoll的封装</h4><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line"><span class="keyword">int</span> epoll_create(<span class="keyword">int</span> size);  </span><br><span class="line"><span class="keyword">int</span> epoll_ctl(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, <span class="keyword">struct</span> epoll_event *event);  </span><br><span class="line"><span class="keyword">int</span> epoll_wait(<span class="keyword">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 对上面三个调用的封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpoll</span><span class="params">(block <span class="keyword">bool</span>)</span> <span class="title">gList</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">netpollinit</span> 会创建一个 <span class="title">epoll</span> 实例，然后把 <span class="title">epoll</span> <span class="title">fd</span> 赋值给 <span class="title">epfd</span>，</span></span><br><span class="line"><span class="function">// 后续 <span class="title">listener</span> 以及它 <span class="title">accept</span> 的所有 <span class="title">sockets</span> 有关 <span class="title">epoll</span> 的操作都是基于这个全局的 <span class="title">epfd</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line"><span class="keyword">if</span> epfd &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> epfd &gt;= <span class="number">0</span> &#123;</span><br><span class="line">closeonexec(epfd)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"runtime: epollcreate failed with"</span>, -epfd)</span><br><span class="line">throw(<span class="string">"runtime: netpollinit failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpollopen 会被 runtime_pollOpen 调用，注册 fd 到 epoll 实例，</span></span><br><span class="line"><span class="comment">// 同时会利用万能指针把 pollDesc 保存到 epollevent 的一个 8 位的字节数组 data 里</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ev epollevent</span><br><span class="line">ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line"><span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="keyword">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">err := netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line"><span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// As for now only Solaris, illumos, and AIX use level-triggered IO.</span></span><br><span class="line"><span class="keyword">if</span> GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"illumos"</span> || GOOS == <span class="string">"aix"</span> &#123;</span><br><span class="line">netpollarm(pd, mode)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进入 netpollblock 并且判断是否有期待的 I/O 事件发生，</span></span><br><span class="line"><span class="comment">// 这里的 for 循环是为了一直等到 io ready</span></span><br><span class="line"><span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">err = netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line"><span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Can happen if timeout has fired and unblocked us,</span></span><br><span class="line"><span class="comment">// but before we had a chance to run, timeout has been reset.</span></span><br><span class="line"><span class="comment">// Pretend it has not happened and retry.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns true if IO is ready, or false if timedout or closed</span></span><br><span class="line"><span class="comment">// waitio - wait only for completed IO, ignore errors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// gpp 保存的是 goroutine 的数据结构 g，这里会根据 mode 的值决定是 rg 还是 wg</span></span><br><span class="line"><span class="comment">// 后面调用 gopark 之后，会把当前的 goroutine 的抽象数据结构 g 存入 gpp 这个指针</span></span><br><span class="line">gpp := &amp;pd.rg</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">'w'</span> &#123;</span><br><span class="line">gpp = &amp;pd.wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set the gpp semaphore to WAIT</span></span><br><span class="line"><span class="comment">// 这个 for 循环是为了等待 io ready 或者 io wait</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">old := *gpp</span><br><span class="line"><span class="comment">// gpp == pdReady 表示此时已有期待的 I/O 事件发生，</span></span><br><span class="line"><span class="comment">// 可以直接返回 unblock 当前 goroutine 并执行响应的 I/O 操作</span></span><br><span class="line"><span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">*gpp = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"runtime: double wait"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有期待的 I/O 事件发生，则通过原子操作把 gpp 的值置为 pdWait 并退出 for 循环</span></span><br><span class="line"><span class="keyword">if</span> atomic.Casuintptr(gpp, <span class="number">0</span>, pdWait) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// need to recheck error states after setting gpp to WAIT</span></span><br><span class="line"><span class="comment">// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl</span></span><br><span class="line"><span class="comment">// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// waitio 此时是 false，netpollcheckerr 方法会检查当前 pollDesc 对应的 fd 是否是正常的，</span></span><br><span class="line"><span class="comment">// 通常来说  netpollcheckerr(pd, mode) == 0 是成立的，所以这里会执行 gopark</span></span><br><span class="line"><span class="comment">// 把当前 goroutine 给 park 住，直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，</span></span><br><span class="line"><span class="comment">// 然后 unpark 返回，在 gopark 内部会把当前 goroutine 的抽象数据结构 g 存入</span></span><br><span class="line"><span class="comment">// gpp(pollDesc.rg/pollDesc.wg) 指针里，以便在后面的 netpoll 函数取出 pollDesc 之后，</span></span><br><span class="line"><span class="comment">// 把 g 添加到链表里返回，接着重新调度 goroutine</span></span><br><span class="line"><span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 注册 netpollblockcommit 回调给 gopark，在 gopark 内部会执行它，保存当前 goroutine 到 gpp</span></span><br><span class="line">gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// be careful to not lose concurrent READY notification</span></span><br><span class="line">old := atomic.Xchguintptr(gpp, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">throw(<span class="string">"runtime: corrupted polldesc"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gopark 会停住当前的 goroutine 并且调用传递进来的回调函数 unlockf，从上面的源码我们可以知道这个函数是</span></span><br><span class="line"><span class="comment">// netpollblockcommit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">waitReason</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">checkTimeouts() <span class="comment">// timeouts may expire while two goroutines keep the scheduler busy</span></span><br><span class="line">&#125;</span><br><span class="line">mp := acquirem()</span><br><span class="line">gp := mp.curg</span><br><span class="line">status := readgstatus(gp)</span><br><span class="line"><span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">throw(<span class="string">"gopark: bad g status"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mp.waitlock = lock</span><br><span class="line">mp.waitunlockf = unlockf</span><br><span class="line">gp.waitreason = reason</span><br><span class="line">mp.waittraceev = traceEv</span><br><span class="line">mp.waittraceskip = traceskip</span><br><span class="line">releasem(mp)</span><br><span class="line"><span class="comment">// can't do anything that might move the G between Ms here.</span></span><br><span class="line"><span class="comment">// gopark 最终会调用 park_m，在这个函数内部会调用 unlockf，也就是 netpollblockcommit，</span></span><br><span class="line"><span class="comment">// 然后会把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</span></span><br><span class="line">mcall(park_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// park continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">_g_ := getg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">dropg()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 调用 netpollblockcommit，把当前的 goroutine，</span></span><br><span class="line"><span class="comment">// 也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</span></span><br><span class="line">ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpollblockcommit 在 gopark 函数里被调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 通过原子操作把当前 goroutine 抽象的数据结构 g，也就是这里的参数 gp 存入 gpp 指针，</span></span><br><span class="line"><span class="comment">// 此时 gpp 的值是 pollDesc 的 rg 或者 wg 指针</span></span><br><span class="line">r := atomic.Casuintptr((*<span class="keyword">uintptr</span>)(gpp), pdWait, <span class="keyword">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line"><span class="keyword">if</span> r &#123;</span><br><span class="line"><span class="comment">// Bump the count of goroutines waiting for the poller.</span></span><br><span class="line"><span class="comment">// The scheduler uses this to decide whether to block</span></span><br><span class="line"><span class="comment">// waiting for the poller if there is nothing else to do.</span></span><br><span class="line">atomic.Xadd(&amp;netpollWaiters, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polls for ready network connections</span></span><br><span class="line"><span class="comment">// returns list of goroutines that become runnable</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(block <span class="keyword">bool</span>)</span> <span class="title">gList</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">waitms := <span class="keyword">int32</span>(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 是否以阻塞模式调用 epoll_wait</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">waitms = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line"><span class="comment">// 获取就绪的 fd 列表</span></span><br><span class="line">n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="keyword">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n != -_EINTR &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">"runtime: epollwait on fd"</span>, epfd, <span class="string">"failed with"</span>, -n)</span><br><span class="line">throw(<span class="string">"runtime: netpoll failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// toRun 是一个 g 的链表，存储要恢复的 goroutines，最后返回给调用方</span></span><br><span class="line"><span class="keyword">var</span> toRun gList</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">ev := &amp;events[i]</span><br><span class="line"><span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mode <span class="keyword">int32</span></span><br><span class="line"><span class="comment">// 判断发生的事件类型，读类型或者写类型</span></span><br><span class="line"><span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">mode += <span class="string">'r'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">mode += <span class="string">'w'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 取出保存在 epollevent 里的 pollDesc</span></span><br><span class="line">pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">pd.everr = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> ev.events == _EPOLLERR &#123;</span><br><span class="line">pd.everr = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用 netpollready，传入就绪 fd 的 pollDesc，把 fd 对应的 goroutine 添加到链表 toRun 中</span></span><br><span class="line">netpollready(&amp;toRun, pd, mode)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> block &amp;&amp; toRun.empty() &#123;</span><br><span class="line"><span class="keyword">goto</span> retry</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpollready 调用 netpollunblock 返回就绪 fd 对应的 goroutine 的抽象数据结构 g</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollready</span><span class="params">(toRun *gList, pd *pollDesc, mode <span class="keyword">int32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rg, wg *g</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">'r'</span> || mode == <span class="string">'r'</span>+<span class="string">'w'</span> &#123;</span><br><span class="line">rg = netpollunblock(pd, <span class="string">'r'</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">'w'</span> || mode == <span class="string">'r'</span>+<span class="string">'w'</span> &#123;</span><br><span class="line">wg = netpollunblock(pd, <span class="string">'w'</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rg != <span class="literal">nil</span> &#123;</span><br><span class="line">toRun.push(rg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> wg != <span class="literal">nil</span> &#123;</span><br><span class="line">toRun.push(wg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpollunblock 会依据传入的 mode 决定从 pollDesc 的 rg 或者 wg 取出当时 gopark 之时存入的</span></span><br><span class="line"><span class="comment">// goroutine 抽象数据结构 g 并返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollunblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, ioready <span class="keyword">bool</span>)</span> *<span class="title">g</span></span> &#123;</span><br><span class="line"><span class="comment">// mode == 'r' 代表当时 gopark 是为了等待读事件，而 mode == 'w' 则代表是等待写事件</span></span><br><span class="line">gpp := &amp;pd.rg</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">'w'</span> &#123;</span><br><span class="line">gpp = &amp;pd.wg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 取出 gpp 存储的 g</span></span><br><span class="line">old := *gpp</span><br><span class="line"><span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; !ioready &#123;</span><br><span class="line"><span class="comment">// Only set READY for ioready. runtime_pollWait</span></span><br><span class="line"><span class="comment">// will check for timeout/cancel before waiting.</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">new</span> <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">if</span> ioready &#123;</span><br><span class="line"><span class="built_in">new</span> = pdReady</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重置 pollDesc 的 rg 或者 wg</span></span><br><span class="line"><span class="keyword">if</span> atomic.Casuintptr(gpp, old, <span class="built_in">new</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> old == pdReady || old == pdWait &#123;</span><br><span class="line">old = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过万能指针还原成 g 并返回</span></span><br><span class="line"><span class="keyword">return</span> (*g)(unsafe.Pointer(old))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Go 在多种场景下都可能会调用 <code>netpoll</code> 检查文件描述符状态。寻找到 I/O 就绪的 socket fd，并找到这些 socket fd 对应的轮询器中附带的信息，根据这些信息将之前等待这些 socket fd 就绪的 goroutine 状态修改为 <code>_Grunnable</code> 。执行完 <code>netpoll</code> 之后，会返回一个就绪 fd 列表对应的 goroutine 列表，接下来将就绪的 goroutine 加入到调度队列中，等待调度运行。</p><p>首先，在 Go runtime scheduler 正常调度 goroutine 之时就有可能会调用 <code>netpoll</code> 获取到已就绪的 fd 对应的 goroutine 来调度执行：</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One round of scheduler: find a runnable goroutine and execute it.</span></span><br><span class="line"><span class="comment">// Never returns.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finds a runnable goroutine to execute.</span></span><br><span class="line"><span class="comment">// Tries to steal from other P's, get g from global queue, poll network.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Poll network.</span></span><br><span class="line"><span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line"><span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line"><span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line"><span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line"><span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line"><span class="comment">// anyway.</span></span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">gp := list.pop()</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line"><span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Go scheduler 的核心方法 <code>schedule</code> 里会调用一个叫 <code>findrunable()</code> 的方法获取可运行的 goroutine 来执行，而在 <code>findrunable()</code> 方法里就调用了 <code>netpoll</code> 获取已就绪的 fd 列表对应的 goroutine 列表。</p><p>另外， <code>sysmon</code> 监控线程也可能会调用到 <code>netpoll</code> ：</p><p>Go runtime 在程序启动的时候会创建一个独立的 M 作为监控线程，叫 <code>sysmon</code> ，这个线程为系统级的 daemon 线程，无需 P 即可运行， <code>sysmon</code> 每 20us~10ms 运行一次。 <code>sysmon</code> 中以轮询的方式执行以下操作（如上面的代码所示）：</p><ol><li>以非阻塞的方式调用 <code>runtime.netpoll</code> ，从中找出能从网络 I/O 中唤醒的 G，并调用 <code>injectglist</code> ，将其插入调度器的 runnable 列表中（全局），调度触发时，有可能从这个全局 runnable 列表获取 G。然后再循环调用 <code>startm</code> ，直到所有 P 都不处于 <code>_Pidle</code> 状态。</li><li>调用 <code>retake</code> ，抢占长时间处于 <code>_Psyscall</code> 状态的 P。</li></ol><p>综上，Go 借助于 epoll/kqueue/iocp 和 runtime scheduler 等的帮助，设计出了自己的 I/O 多路复用 netpoll，成功地让 <code>Listener.Accept</code> / <code>conn.Read</code> / <code>conn.Write</code> 等方法从开发者的角度看来是同步模式</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">now := nanotime()</span><br><span class="line"><span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line"><span class="comment">// 以非阻塞的方式调用 netpoll 获取就绪 fd 列表</span></span><br><span class="line">list := netpoll(<span class="literal">false</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line"><span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line"><span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line"><span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line"><span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line"><span class="comment">// injectglist grabs all P's but before it starts M's to run the P's,</span></span><br><span class="line"><span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line"><span class="comment">// observes that there is no work to do and no other running M's</span></span><br><span class="line"><span class="comment">// and reports deadlock.</span></span><br><span class="line">incidlelocked(<span class="number">-1</span>)</span><br><span class="line"><span class="comment">// 将其插入调度器的runnable列表中（全局），等待被调度执行</span></span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">incidlelocked(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// retake P's blocked in syscalls</span></span><br><span class="line"><span class="comment">// and preempt long running G's</span></span><br><span class="line"><span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">idle = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">idle++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// check if we need to force a GC</span></span><br><span class="line"><span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">lock(&amp;forcegc.lock)</span><br><span class="line">forcegc.idle = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> list gList</span><br><span class="line">list.push(forcegc.g)</span><br><span class="line">injectglist(&amp;list)</span><br><span class="line">unlock(&amp;forcegc.lock)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">lasttrace = now</span><br><span class="line">schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;导读&lt;/h2&gt;
&lt;p&gt;工作三年，接触过java，python，golang的一些常用的web框架，网络编程库，并发编程模式之后，渐渐开始掌握了网络编程的一些核心的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;socket编程&lt;/li&gt;
&lt;li&gt;io模型&lt;/li&gt;
&lt;li&gt;并发模型&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/7.%20%E7%8E%B0%E4%BB%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84io%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/7. 现代编程语言里的io模型/</id>
    <published>2020-04-30T16:36:12.390Z</published>
    <updated>2020-04-30T16:36:44.106Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/6.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8Cio/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/6. 操作系统的文件系统和io/</id>
    <published>2020-04-30T16:34:56.382Z</published>
    <updated>2020-04-30T16:36:05.708Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/5.%20%E7%8E%B0%E4%BB%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/5. 现代编程语言里的并发模型/</id>
    <published>2020-04-30T16:33:38.668Z</published>
    <updated>2020-04-30T16:33:57.037Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/4.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B_%E8%B0%83%E5%BA%A6_%E5%90%8C%E6%AD%A5_%E4%BA%92%E6%96%A5/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/4. 操作系统的进程_调度_同步_互斥/</id>
    <published>2020-04-30T16:33:04.150Z</published>
    <updated>2020-05-01T03:34:23.547Z</updated>
    
    <content type="html"><![CDATA[<p>当我们讨论进程，我们首先要意识到，它存在的目的是为了时分复用cpu的资源，而某种意义上来说操作系统就是一个巨大的可以执行特权级指令的进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们讨论进程，我们首先要意识到，它存在的目的是为了时分复用cpu的资源，而某种意义上来说操作系统就是一个巨大的可以执行特权级指令的进程。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/1.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/1. 操作系统概述/</id>
    <published>2020-04-30T16:32:26.411Z</published>
    <updated>2020-05-01T03:29:12.920Z</updated>
    
    <content type="html"><![CDATA[<p>我相信没有比操作系统启动的时候做了什么和当我们启动应用的时候操作系统做了什么两个问题更容易让我们对操作系统的核心概念由更直接的认识。</p><h2>操作系统的硬件基础</h2><h2>操作系统加电启动过程</h2><h3>流程简述</h3><p>80386体系，操作系统的初始化主要流程是：</p><ol><li>cpu加电启动，到ROM上调用BIOS程序</li></ol><p>​    cpu加电启动，cp和sp的寄存器只存有一条跳转指令，到ROM的BIOS，80386的跳转物理地址是OxFFFFFFF0</p><ol start="2"><li>BIOS启动，完成硬件自检和初始化(检测什么TODO:)</li></ol><p>​    选择一个启动设备，硬盘，光盘，u盘都可以</p><ol start="3"><li>BIOS调用硬盘引导扇区里的bootloader到内存</li></ol><p>​    BIOS读取硬盘的第一个扇区(512字节)，称为主引导扇区或者启动扇区到内存特定地址(Ox7c00)</p><ol start="4"><li><p>cpu的控制权交给bootloader（执行bootloader的代码）</p></li><li><p>bootloader完成自己的任务</p></li></ol><ul><li><p>切换到保护模式，启动分段机制</p></li><li><p>读取磁盘中ELF格式的操作系统内核文件到内存</p></li><li><p>把控制权交给操作系统</p></li></ul><ol start="6"><li>操作系统</li></ol><h5>实模式和保护模式</h5><p>实模式切换保护模式的核心是：</p><ol><li><p>使能A20地址线，增大寻址能力，为加载os kernel进程印象（把os当作一个大的进程）做准备</p></li><li><p>初始化GDT表，用于虚拟内存到物理内存的映射</p></li></ol><p>保护模式的特点：</p><ol><li><p>地址32位全部有效，可物理寻址范围是4GB</p></li><li><p>可以在硬件层面实现虚拟存储：段页式存储</p></li><li><p>可以在硬件层面提供存储的共享和保护</p><p>实模式下，缺少硬件层面的存储和保护，缺少特权级指令的支持，操作系统和用户进程都拥有相同的权利,危险程度不言而喻。</p></li></ol><h5>段式内存管理</h5><p>​    保护模式下，有GDT和LDT两个段表，可以存储2*8192（2^13）= 2^14个段，相当于可寻址的虚拟地址空间为2^30 * 2^14，但是虚拟地址最终还是会转化为物理地址，所以这个巨大的值没有意义</p><p>​    分段就是地址分为(base_addr起始地址, offset段偏移)的二维参数</p><h5>地址空间</h5><h5>硬盘访问</h5><h5>elf格式文件</h5><h3>bootloader实模式切换到保护模式（汇编代码操作寄存器的操作</h3><p>bootloader首先要切换到保护模式运行，这样才能寻址到更高地址的os内核</p><h3>bootloader加载ELF格式的os kernel</h3><ol><li><p>读取elf头</p></li><li><p>校验</p></li><li><p>根据elf文件的描述表加载elf文件到内存特定位置</p></li></ol><h3>操作系统的启动过程</h3><h5>函数和堆栈</h5><p>![image-20200501103206233](/Users/qicheng.li/Library/Application Support/typora-user-images/image-20200501103206233.png)</p><h5>中断和异常</h5><p>操作系统中有三种中断机制：</p><ol><li>外部中断：io/时钟/控制台（异步中断，时间不确定）</li><li><strong>异常</strong>(内部中断)：除0中断/地址访问越界（同步）</li><li>trap（陷入trap中断/软中断//系统调用）</li></ol><p>这里只介绍1和2，cpu通过8259中断控制器收到中断，cpu会：</p><ol><li>暂停当前的程序/任务（保存环境:保存寄存器的值放到内存中，具体来说是内存中栈的位置），产生一个trapframe（trapframe保存有中断的信号类型，当前寄存器的状态，用于找到指定的处理函数和恢复现场</li><li>跳到负责这个中断信号的处理程序（中断向量表IDT[interrupt descripte table]，IDT的地址存放在cpu的idtr寄存器中），根据trapframe找到对应的函数，执行中断处理</li><li>处理完成之后，根据trapframe恢复现场</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我相信没有比操作系统启动的时候做了什么和当我们启动应用的时候操作系统做了什么两个问题更容易让我们对操作系统的核心概念由更直接的认识。&lt;/p&gt;
&lt;h2&gt;操作系统的硬件基础&lt;/h2&gt;
&lt;h2&gt;操作系统加电启动过程&lt;/h2&gt;
&lt;h3&gt;流程简述&lt;/h3&gt;
&lt;p&gt;80386体系，操作
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/0.%20README/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/0. README/</id>
    <published>2020-04-30T16:32:13.971Z</published>
    <updated>2020-04-30T17:28:43.817Z</updated>
    
    <content type="html"><![CDATA[<h2>写在前面</h2><h4>谈谈为什么要学操作系统</h4><p>工作三年了，作为一个后端开发工程师，如果你问我大学最后悔的事是什么，我一定会回答：“没有学好操作系统”。没有扎实的操作系统基础，想要在后端快速提升自己的技术实力有点天方夜谭了，而我，就一直吃着这个亏。</p><ol><li>当我学习docker这门技术的时候，发现docker技术本身都在操作系统里</li><li>当我想要深入理解一门编程语言的实现的时候，发现其背后也离不开对操作系统的理解</li><li>当我想要去做一个toydb的时候，我发现我对操作系统的io的理解是如此的浅薄</li></ol><p>最近pingcap的各位老师们完成了一个壮举，在一个周末内通过多人协作，在github完成了一本tidb的书本。所以我也要尝试，在2020年的5-1劳动节的5天假期内，完成《重学操作系统》系列的文章的壮举。</p><p>由于个人知识水平有限，大学操作系统课程也没学扎实，希望大家多多包涵，强烈欢迎指正我文章里面的知识性错误，不让我的错误祸害他人，毕竟，我的本意只是为了分享而已。</p><p>这系列的文章可能不会有很细节的知识点，可能对某一方面的知识解读的不够全面，它存在的意义不是作为教科书和，作为学习笔记。更多的是一种知识的脉络梳理，一种思考和学习的方式。从这个角度去想，我写的这些文字，还是有点意义的。</p><h4>谈谈怎么学习操作系统</h4><p>我认为快速掌握操作系统的基础，离不开两点：</p><ol><li>理论结合实践</li><li>建立起知识的脉络</li></ol><h6>说说实践</h6><p>在我毕业之后的很长一段时间里，我都忘不了被操作系统各种概念支配的恐惧，什么进程，线程，内存管理，各种内存分配算法，太多的理论知识，太多的强行理解，比如，进程是什么，哦，我现在码字的typora就是一个进程，这些似对似错的理解，根本让人建立不起直觉上的认知，以至于学完就忘了。</p><h6>说说知识脉络</h6><p>操作系统可以和很多知识建立起联系。比如计算机网络，算法和数据结构，现代编程语言。让知识成为孤岛，人的脑容量是远远不够的，人类神经元的结构就是一张网络，当我们的知识也形成一张网络的时候，我们才能加深理解，记住和掌握它们。</p><h4>谈谈操作系统的核心知识点</h4><h2>参考资料</h2><p>清华操作系统实验课：《ucore操作系统》</p><p>北大陈向群老师的操作系统原理课程</p><p>golang源码剖析</p><p>java虚拟机</p><p>《unix网络编程卷1/2》</p><p>《unix系统编程》</p><p>《7周7并发编程模型》</p><p>极客时间 - 编译原理</p><h2>联系方式</h2><p>微信</p><p>微信公众号</p><p>知乎</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;写在前面&lt;/h2&gt;
&lt;h4&gt;谈谈为什么要学操作系统&lt;/h4&gt;
&lt;p&gt;工作三年了，作为一个后端开发工程师，如果你问我大学最后悔的事是什么，我一定会回答：“没有学好操作系统”。没有扎实的操作系统基础，想要在后端快速提升自己的技术实力有点天方夜谭了，而我，就一直吃着这个亏。&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/3.%20%E7%8E%B0%E4%BB%A3%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%87%8C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/3. 现代编程语言里的内存管理/</id>
    <published>2020-04-30T16:31:38.636Z</published>
    <updated>2020-04-30T17:25:21.841Z</updated>
    
    <content type="html"><![CDATA[<h2>内存模型</h2><h4>java的内存模型</h4><h4>golang的内存模型</h4><h2>内存分配</h2><h2>垃圾回收</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;内存模型&lt;/h2&gt;
&lt;h4&gt;java的内存模型&lt;/h4&gt;
&lt;h4&gt;golang的内存模型&lt;/h4&gt;
&lt;h2&gt;内存分配&lt;/h2&gt;
&lt;h2&gt;垃圾回收&lt;/h2&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://lqczzz.github.io/2020/05/01/ucore/2.%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://lqczzz.github.io/2020/05/01/ucore/2. 操作系统内存管理/</id>
    <published>2020-04-30T16:31:15.912Z</published>
    <updated>2020-05-01T14:43:58.988Z</updated>
    
    <content type="html"><![CDATA[<p>当我们谈论操作系统的内存管理的时候，我们需要意识到，内存的管理本质上就是操作系统提供的一种对RAM内存的管理机制。通过空分复用技术来实现有限的内存空间的访问，毕竟现实中并没有图灵机假象的那一条无穷的指令条，即便存在，人类也无法掌控。</p><p>这里主要介绍了物理内存管理和虚拟内存管理，前者主要还是对空间内存空间的管理，后者是对多级存储的黑盒化，把内存和硬盘结合在一起，让你得到更大的内存，后者 更多的是对前者的补充，试想，如果物理内存无限大，那何必要去做内存虚拟化，何必要把一些内存页置换到硬盘上呢。</p><h2>物理内存管理</h2><p>物理内存管理主要需要两个“能力”</p><p>一个是管理物理页的链表，用来分配内存</p><p>一个是启动段页式内存映射关系，用来做地址转化</p><p>在虚拟内存管理中，经常需要在缺页异常之后，通过1来获得一个物理内存，通过2建立虚拟内存和物理内存的映射关系</p><h4>物理内存布局的探索</h4><p>实模式下，bootloader调用BIOS的中断来把内存信息写入到固定位置的一块内存区域中</p><p>bootloader加载ucore之后，ucore从这块区域中获取到具体的内存布局信息</p><h4>页式的内存管理</h4><p>这一步主要是建立一个数据结构用于管理内存，我们用PageFrame表示一块4k大小的物理内存的话，而PageFrame结构体存储需要4字节的话，意味着4G的内存空间需要4MB的内存来建立映射（索引），这部分映射的数据结构存储在操作系统内核空间之上。</p><h4>物理页分配算法</h4><p>算法有很多种，但是算法框架的核心在于：</p><ul><li><p>Init() - 初始化物理内存管理组件，通常是一块空闲链表</p></li><li><p>Alloc()</p></li><li><p>Free()</p></li></ul><h4>实现分页机制</h4><p>把一级页目录表的地址放在cr3寄存器中，每个进程有自己的二级页表。也就是说，分页机制需要在操作系统完成物理内存嗅探，建立好数据结构用于空闲内存管理之后才能启动分页机制（建立页表)，</p><h2>虚拟内存管理</h2><p>物理内存让用户看到的内存不再是实际的物理内存，通过页表项来限定程序的运行访问空间，可以有效防止运行不越界。而虚拟内存技术是通过页换入换出，按需加载页的机制，为实现更多进程并发运行提供更大的“内存”空间。</p><h2>多核时代的内存模型</h2><h4>可见性和一致性</h4><p>一致性分为：</p><p>线性一致性</p><h4></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们谈论操作系统的内存管理的时候，我们需要意识到，内存的管理本质上就是操作系统提供的一种对RAM内存的管理机制。通过空分复用技术来实现有限的内存空间的访问，毕竟现实中并没有图灵机假象的那一条无穷的指令条，即便存在，人类也无法掌控。&lt;/p&gt;
&lt;p&gt;这里主要介绍了物理内存管理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向开发人员的kubernetes笔记</title>
    <link href="http://lqczzz.github.io/2020/03/30/%E9%9D%A2%E5%90%91%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84kubernetes%E7%AC%94%E8%AE%B0/"/>
    <id>http://lqczzz.github.io/2020/03/30/面向开发人员的kubernetes笔记/</id>
    <published>2020-03-29T17:14:49.000Z</published>
    <updated>2020-04-02T17:37:47.070Z</updated>
    
    <content type="html"><![CDATA[<p>这边笔记涵盖了以下内容：</p><ul><li>容器虚拟化的原理</li><li>容器编排的基本概念</li><li>k8s的容器编排对象</li><li>k8s的集群架构和基本原理</li><li>容器编排的实践</li></ul><p>参考学习材料</p><ul><li><p>《docker进阶与实战》</p></li><li><p>《kubernetes in action》ch1-ch11</p></li><li><p>极客时间《深入剖析Kubernetes》</p></li></ul><h2>容器&amp;docker</h2><h4>docker的虚拟化原理</h4><p>Namespace 做隔离，Cgroups 做限制，rootfs 做文件系统</p><p>本质上依然是一个进程</p><h5>Namespace 做隔离</h5><p>namespace用于对全局资源的隔离</p><p>已经有的：</p><ul><li>ipc</li><li>network</li><li>mount</li><li>pid</li><li>uts</li><li>user</li></ul><p>通常的操作：</p><p>clone： 创建新的namespance</p><p>setns：把进程放进已有的namespace里</p><h5>Cgroups 做限制</h5><ul><li><p>cpuset子系统：限制可用的cpu列表</p></li><li><p>cpu子系统：限制cpu利用率</p></li><li><p>memory子系统：限制内存使用率</p></li><li><p>...</p></li></ul><h5>rootfs 做文件系统</h5><p>进程使用pivot_root系统调用来做跟文件系统的切换</p><p>（union mount来分层镜像）</p><h2>容器编排&amp;kubernetes</h2><h3>什么是容器编排(Container Orchestration）</h3><p>容器编排是为了简化服务的开发和运维，提升基础设施利用率的工具。</p><p>容器编排核心关注的是以下几个点</p><ol><li><p>Workloads</p></li><li><p>Scheduler</p></li><li><p>Networking</p></li><li><p>Storage</p></li></ol><p>workloads是最小的部署单元，比如我们手动在服务器上启动web服务：<code>python manager runserver</code>,可以认为最小的部署单元是一个进程。workloads包含了network/memory/cpu等资源的需求。</p><p>scheduler主要功能有三个：</p><ul><li>控制着workloads的生命周期，包括创建，销毁，health check</li><li>控制着workloads之间的约束关系：Coordination/Replica/Dependency</li><li>workloads的扩容缩容/更新/回滚等</li></ul><p>Networks关注集群的网络模型（L3/L4)/DNS/service discovery/load balance</p><p>存储主要分为volumn &amp; persistence volumn</p><p>kubernetes是起源于google的borg&amp;omega的容器编排工具</p><p><img src="/images/k8s_1/image-20200329213121557.png" alt="image-20200329213121557"></p><h3>kubernetes的集群架构</h3><p>从硬件角度看，一个kubernetes集群有很多节点(node)组成，每个节点可以是物理机/虚拟机，这些节点被分为两种类型：</p><ul><li><p>master：集群的管理</p></li><li><p>worker：运行用户实际部署的应用</p></li></ul><p><img src="/images/k8s_1/image-20200329220457602.png" alt="image-20200329220457602"></p><p>master主要有四个组件</p><ul><li>etcd：提供线性一致性的存储，用于存储集群的配置信息/leader 选举</li><li>api server：etcd的代理，提供etcd的配置变更接口，变更监听的能力</li><li>scheduler：调度应用（给应用分配可部署的节点）</li><li>controller manager：跟踪工作节点，处理工作节点失效等集群的功能</li></ul><p>worker nodes主要有三个组件</p><ul><li><p>kubelet：管理节点的容器</p></li><li><p>kube-proxy：组件之间的负载均衡网络流量</p></li><li><p>Container runtime:容器运行时</p></li></ul><h3>kubernetes的资源对象</h3><p>kubernetes的资源对象包括了pod/deployment/service等等各种各样的资源。</p><p><img src="/images/k8s_1/image-20200329221527443.png" alt="image-20200329221527443"></p><p>kubernetes的资源对象都是通过yaml或者json描述文件来创建的，<code>kubebctl</code>也提供了一些简单的命令创建一组属性有限的资源对象。</p><h4>1. pod - 最小的调度单位(workloads)</h4><h5>pod的结构</h5><p>kubernetes使用pod作为最小调度单位，pod是一组共享了某些资源的容器</p><p>具体的说，共享了net/uts/ipc/pid namespace，所以具有相同的loopback网络接口，可以进行ipc通信等，但是挂载文件系统是隔离的（文件系统来自于容器镜像）</p><p><img src="/images/k8s_1/image-20200329223022331.png" alt="image-20200329223022331"></p><ul><li>pod里的容器必须运行在相同的节点，解决了成组调度的问题</li><li>Infra 容器是一个非常特殊的镜像，叫作：k8s.gcr.io/pause。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右</li><li>pod之间的网络没有NAT转换</li><li>Pod 扮演的是传统部署环境里“虚拟机”的角色，调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的</li></ul><h5>容器设计模式</h5><p>主容器运行应用，sidecar进程运行住进程之外的工作</p><p>eg：</p><ul><li>war &amp;&amp; tomcat</li><li>应用和日志搜集</li><li>istio sidecar</li></ul><h5>pod的资源描述</h5><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1 # api版本</span><br><span class="line">kind: Pod # 资源类型</span><br><span class="line">metadata: # 名称/命名空间(namespace)/标签(label)</span><br><span class="line">  name: kubia-manual</span><br><span class="line">spec: # pod内容的实际说明，例如容器/volume等</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa/kubia</span><br><span class="line">    name: kubia</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      protocol: TCP</span><br><span class="line"># status: # status是运行时资源的状态</span><br></pre></td></tr></table></figure></p><ul><li><p>使用命名空间对资源进行分组(没有隔离作用)</p></li><li><p>使用标签和选择器来约束pod的调度</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">nodeSelector:</span><br><span class="line">labelKey: labelValue</span><br></pre></td></tr></table></figure></p></li></ul><h4>2. deployment - 声明式的升级应用</h4><h5>从replicationController(rc)说起</h5><p><img src="/images/k8s_1/image-20200330003811291.png" alt="image-20200330003811291"></p><p>通过给pod配置存活探针，kubernetes检测pod本身的状态</p><ul><li>当pod出现问题，replicationController会自动拉起一个新的pod</li><li>修改replicationController的replicas，可以实现动态扩容缩容</li><li>修改replicationController的template,可以升级应用(修改之后再删除原有的，因为修改template并不会影响现有的运行中的pod，这是一种停机升级)</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3 # 副本数量</span><br><span class="line">  selector: # 根据label选择pod</span><br><span class="line">    app: kubia</span><br><span class="line">  template: # 声明被控制的对象（俄罗斯套娃</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa/kubia</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br></pre></td></tr></table></figure></p><h5>deployment直接作用的是rs不是pod</h5><p>replicationSet(rs)就是label选择表达式更加丰富了的rc。</p><p>没有deployment的时候，升级的应用的方式有：</p><ol><li>使用一个rc，停机升级：先修改template，删除旧pod，然后创建新的pod</li></ol><p><img src="/images/k8s_1/image-20200330005629376.png" alt="image-20200330005629376"></p><ol start="2"><li>使用两个rc，不停机升级：先修改template，删除旧pod，然后创建新的pod</li></ol><p><img src="/images/k8s_1/image-20200330005650536.png" alt="image-20200330005650536"></p><ol start="3"><li>手动执行滚动升级</li></ol><p><img src="/images/k8s_1/image-20200330005740322.png" alt="image-20200330005740322"></p><p>使用了deployment实现自动滚动升级(kubernetes自动控制)</p><p><img src="/images/k8s_1/image-20200330010423544.png" alt="image-20200330010423544"></p><ul><li>deployment滚动升级过程也是通过创建新的rs逐步替换旧pod，旧的rs不删除</li><li>保留旧的rs，方便回滚</li><li>支持暂停升级（相当于运行了一个金丝雀版本的app）</li></ul><h5>其他的编排对象</h5><ul><li><p>daemon set： 给每个node都创建一个pod</p><p>eg：kube-proxy，日志搜集程序，servicemesh网格/sidecar</p></li><li><p>job:一次性任务/定时任务</p></li><li><p>stateful set：有状态的pods的编排对象</p></li></ul><h5>其他编排方式：蓝绿/金丝雀(灰度)...</h5><p>https://github.com/ContainerSolutions/k8s-deployment-strategies</p><h4>3. service - 让客户端发现pod&amp;和pod通信</h4><p>service主要解决两个问题：</p><ol><li>pod随机调度引起的pod应用定位的问题</li><li>pod的流量的负载均衡</li></ol><p>service提供稳定的ip地址来访问pod</p><p>service的ip地址是虚拟ip地址(vip)，无法ping通</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports: # 提供多个端口映射</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure></p><h5>服务发现</h5><p>主要通过环境变量和DNS用于发现服务</p><ul><li><p>环境变量</p><p>XXX_SERVICE_HOST</p><p>XXX_SERVICE_PORT</p><p>(XXX为服务名字)</p></li><li><p>DNS</p><p>{service_name}.{namespace}.{可配置的集群域后缀}</p><p>eg：kubia.default.svc.cluster.local</p></li></ul><h5>连接外部服务</h5><p><img src="/images/k8s_1/image-20200402213710432.png" alt="image-20200402213710432"></p><p>连接service和pod的是一种叫做endpoint的资源，endpoint资源是一组服务的ip地址和端口列表</p><p>手动配置endpoint指向外部的ip/域名，可以使得服务得以访问相应的外部服务</p><h5>对外暴露服务</h5><h6>nodeport</h6><p>把任意集群节点的端口的流量转发到内部的service ip端口</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-nodeport</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 # service 端口</span><br><span class="line">    targetPort: 8080 # pod容器端口</span><br><span class="line">    nodePort: 30123 # 集群的节点的端口</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure></p><p><img src="/images/k8s_1/image-20200402213019107.png" alt="image-20200402213019107"></p><h6>负载均衡器</h6><p>在nodeport基础上做了一层负载均衡</p><p><img src="/images/k8s_1/image-20200402213121550.png" alt="image-20200402213121550"></p><h6>ingress</h6><p>ingress提供多个服务的负载均衡，本质上是k8s对反向代理的一种抽象(nginx/haproxy...)</p><p><img src="/images/k8s_1/image-20200402213743308.png" alt="image-20200402213743308"></p><p>ingress不转发请求给service，而是通过service来选择一个pod</p><p><img src="/images/k8s_1/image-20200402213913111.png" alt="image-20200402213913111"></p><h5>headless服务</h5><p>通过讲服务的spec配置项clusterIP设置为none，DNS查询不返回service的vip，而是返回多个A记录（每个pod一个）</p><h4>4. volume - 将磁盘挂在到pod中</h4><p>docker的文件系统来自于镜像，通过volume实现pod中多个容器的文件共享</p><h5>常用volume</h5><h6>emptyDir</h6><p>磁盘临时文件，pod删除，卷内容会被回收</p><h6>hostPath</h6><p>挂载工作节点（host机器）上的文件，类似于shopee的日志</p><h6>gitRepo</h6><p>git仓库同步的目录（不能一直保持同步）</p><h5>persistence volume</h5><p>Pv/pvc/storage class</p><p>pvc：持久卷声明，面向用户(开发)，类似于接口。是用户需求清单的抽象</p><p>pv：持久卷，面向运维，类似实现了pvc的对象，运维可以随意替换存储介质的实现</p><p>storage class：实现了pvc的类，可以通过storage class模版化的生成pv</p><p><img src="/images/k8s_1/image-20200402213913111.png" alt="image-20200402215322964"></p><h5>Projected Volume</h5><p>常用配置应用程序的方式有：命令行参数/配置文件读取/环境变量读取。</p><p>projected volume是配置资源的抽象，但是最终让用户/应用进程所感知的方式同样是上面三种</p><p>抽象配置资源，可以独立配置声明的yaml文件和部署资源的yaml文件</p><h6>configmap</h6><p>存储非敏感的文本配置数据</p><h6>secret</h6><p>用于传递证书/私钥之类的敏感数据</p><h6>downward api</h6><p>用来和k8s通信/获取pod元数据的</p><h6>ServiceAccountToken</h6><h3>kubernetes运行原理</h3><h4>组件</h4><p><img src="/images/k8s_1/image-20200329213556137.png" alt="image-20200329213556137"></p><p>k8s组件主要分为：</p><ul><li>控制面板<ul><li>etcd</li><li>apiserver</li><li>scheduler</li><li>controller manager</li></ul></li><li>工作节点<ul><li>kubelet</li><li>kube-proxy</li><li>容器运行时</li></ul></li><li>附加组件<ul><li>K8s DNS服务器</li><li>dashboard</li><li>ingress控制器</li><li>集群监控</li><li>CNI（容器网络接口插件）</li></ul></li></ul><p>几个点：</p><ul><li>etcd是唯一的存储组件（raft协议，线性一致性的存储系统）</li><li>apiserver是唯一的和etcd交互的组件（apiserver实现了乐观锁机制，能保证冲突被正常处理）</li><li>apiserver以外的组件之间的通信都是通过apiserver进行</li><li>etcd和apiserver是多实例同时运行，其他组件虽然多实例，但只有一个主节点处于工作状态（利用etcd选举）</li><li>除了kubelet外，其他组件都可以作为pod来运行</li></ul><h5>1) etcd - 存储介质</h5><h5>2) apiserver - k8s的api，类似系统调用之于于操作系统</h5><ol><li><p>集群资源和状态的crud</p><p><img src="/images/k8s_1/image-20200402223335663.png" alt="image-20200402223335663"></p></li><li><p>资源变更的通知</p></li></ol><p><img src="/images/k8s_1/image-20200402223352288.png" alt="image-20200402223352288"></p><h5>3) 调度器 - 分配节点</h5><p>调度器调度流程：</p><ol><li>调度器监听api server中所有更新的pod的定义</li><li>选择一个合适的节点（涉及到调度策略）</li><li>更改pod中<code>nodeName</code>的声明</li><li>apiserver通知对应节点的kubelet</li><li>kubelet部署pod</li></ol><h5>4) controller manager - 让集群状态向api定义的期望状态收敛</h5><p>控制器包括</p><ul><li>deployment controller</li><li>node controller</li><li>service controller</li><li>endpoints controller</li><li>namespace controller</li><li>...</li></ul><p>有些controller依赖外部组件，比如ingress controller，就是坚挺apiserver里ingress资源的变更，然后更新ingress的基础设施(nginx/haproxy等)的配置，动态修改配置，让集群的状态变成我们期待的状态（资源声明)</p><h5>5) kubelet</h5><p>主要工作有：</p><ol><li><p>注册node到apiserver</p></li><li><p>启动pod容器</p></li><li><p>持续监控容器，向apiserver报告</p></li></ol><h5>6）kube-proxy</h5><p>Cluster IP与NodePort等概念是kube-proxy服务通过iptables的NAT转换实现的，kube-proxy在运行过程中动态创建与Service相关的iptables规则，这些规则实现了将访问服务（Cluster IP或NodePort）的请求负载分发到后端Pod的功能</p><p><img src="/images/k8s_1/image-20200403011056624.png" alt="image-20200403011056624"></p><h6>运行模式</h6><p><img src="/images/k8s_1/image-20200402231301311.png" alt="image-20200402231301311"></p><p>最开始用于修改iptable规则，同时作为proxy组件代理请求进出，所以叫kube-proxy(性能差， 内核和用户态之间传输数据)</p><p><img src="/images/k8s_1/image-20200402231314698.png" alt="image-20200402231314698"></p><p>完全iptable模式，性能较高</p><h5>7) 插件</h5><p>通过yaml声明，作为daemonset/deployment/replicationController资源部署</p><h4>控制器工作流</h4><p><img src="/images/k8s_1/image-20200402231908550.png" alt="image-20200402231908550"></p><p>所有组件执行动作的时候都会生成一个事件资源发送给apiserver，可以直接观测到</p><h4>跨pod网络(service/DNS/服务发现)</h4><p>k8s的网络的原则：</p><ol><li>每个pod具有唯一的ip</li><li>pod之间的通信没有NAT</li></ol><p><img src="/images/k8s_1/image-20200402232325392.png" alt="image-20200402232325392"></p><h5>1. 同一个pod内不同的容器通信</h5><p>同一个pod内的容器共享net namespace，共享协议栈，等同于在相同主机通信</p><h5>2. 同一节点的通信原理（和docker的CNM一样</h5><p><img src="/images/k8s_1/image-20200402232551057.png" alt="image-20200402232551057"></p><h6>桥接网络模式</h6><p>Pod a ping pod b:</p><ol><li>ping进程构造ICMP echo请求包，并通过socket发给协议栈，</li><li>协议栈根据目的IP地址和系统路由表，知道去10.1.1.2的数据包应该要由10.1.1.1口出去</li><li>由于是第一次访问10.1.1.1，且目的IP和本地IP在同一个网段，所以协议栈会先发送ARP出去，询问10.1.1.1的mac地址</li><li>协议栈将ARP包交给eth0，让它发出去</li><li>由于eth0的另一端连的是veth123，所以ARP请求包就转发给了veth123</li><li>由于veth123的另一端连的是bridge，所以ARP请求包就转发给了bridge</li><li>arp包继续到达beth234和podb的eth0</li><li>eth0把arp包往上抛给协议栈，协议栈发现自己的设备有这个ip，返回arp应答（没有就抛弃</li></ol><p>ps：公司使用的是host网络（容器和宿主机具有相同的ip地址</p><h5>3. 跨节点的通信原理</h5><p><img src="/images/k8s_1/image-20200402234517386.png" alt="image-20200402234517386"></p><p>不同节点之间的网桥以某种形式连接</p><ul><li><p>三层网络</p></li><li><p>二层网络</p></li></ul><p>具体由CNI插件来实现</p><ul><li>calico</li><li>flannel<ul><li>udp</li><li>vxlan</li><li>Host-gw</li></ul></li></ul><h6>UDP</h6><p><img src="/images/k8s_1/image-20200402235448264.png" alt="image-20200402235448264"></p><ul><li>Docker0（br）通过host机器上的路由表，转发请求到flannel0</li><li>flannel0是一个tun设备，把请求转发到用户空间的flanneld程序</li><li>flanneld查找etcd，找到目的容器ip对应的节点ip</li><li>套娃一层ip包</li><li>通过宿主机etho0转发udp包到公网</li><li>...</li></ul><h6>vxlan</h6><p><img src="/images/k8s_1/image-20200403000010564.png" alt="image-20200403000010564"></p><ul><li><p>在现有的三层网络之上，“覆盖”一层虚拟的、由内核 VXLAN 模块负责维护的二层网络，使得连接在这个 VXLAN 二层网络上的“主机”（虚拟机或者容器都可以）之间，可以像在同一个局域网（LAN）里那样自由通信</p></li><li><p>目的 VTEP 设备的arp表在节点创建的时候生成</p></li></ul><h6>host-gw</h6><p><img src="/images/k8s_1/image-20200403002417215.png" alt="image-20200403002417215"></p><ul><li>路径更短，性能更高</li><li>但是节点之间必须是二层联通的（通过路由表吓一跳mac地址设置目的地址，通过二层网络传输</li></ul><h2>常用kubectl的命令（持续更新</h2><h4>资源信息</h4><ol><li>kubectl explain po/ns ...</li></ol><h4>pod</h4><h6>pod</h6><ol><li><p>创建pod - 通过yaml文件</p><p>kubectl create -f xxx.yaml</p></li><li><p>查看运行时pod的完整定义</p><p>kubectl get po poname -o yaml（-o 表示格式yaml/json）</p></li><li><p>查看pod日志</p><p>kubectl logs podname (只有一个容器时候)</p><p>kubectl logs podname -c containername (不只有一个容器时候)</p></li><li><p>本地ssh端口转发</p><p>kubectl port-forward podname localPort:podPort</p></li><li><p>删除pod</p><p>kubectl delete po podname</p><p>kubectl delete po -l labelKey=labelValue</p><p>kubectl delete ns nsName</p><p>kubectl delete po --all</p><p>kubectl delete all --all</p></li></ol><h6>label</h6><ol><li>创建标签<ul><li>通过命令</li><li>通过yaml文件</li></ul></li></ol><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx</span><br><span class="line">metadata:</span><br><span class="line">name: podname</span><br><span class="line">labels:</span><br><span class="line">labelkey: labelval</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>查看标签</p><ul><li>列表带标签</li></ul><p>kubectl get po --show-labels</p><p>Kubectl get po -L labelkey1，labelkey2</p><ul><li>通过标签过滤</li></ul><p>Kubectl get po -l labelkey</p><p>Kubectl get po -l labelkey=labelval</p><p>Kubectl get po -l labelkey='!labelval'</p></li><li><p>修改标签</p><p>Kubectl label po podname labelkey=labbelval</p><p>Kubectl label po podname labelkey=labbelval --overwrite(修改已存在的)</p></li><li><p>使用标签分类工作节点</p><p>Kubectl label node codename labelkey=labelval</p></li><li><p>查看pod详细信息</p><p>Kubectl describe po podname</p></li><li><p>添加注解</p><p>Kubectl annotate pod podname key=value</p></li></ol><h6>namespace</h6><ol><li><p>创建命名空间</p><ul><li>yaml</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: custom-ns</span><br></pre></td></tr></table></figure></p><ul><li><p>kubectl 方式:</p><p>kubectl create namespace custom-ns</p></li></ul></li><li><p>查看namespace</p><p>kubectl get ns</p></li><li><p>查看namespace中的所有pods</p><p>kubectl get po -n namespaceName</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这边笔记涵盖了以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器虚拟化的原理&lt;/li&gt;
&lt;li&gt;容器编排的基本概念&lt;/li&gt;
&lt;li&gt;k8s的容器编排对象&lt;/li&gt;
&lt;li&gt;k8s的集群架构和基本原理&lt;/li&gt;
&lt;li&gt;容器编排的实践&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考学习材料&lt;/p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对数据系统架构设计权衡的思考</title>
    <link href="http://lqczzz.github.io/2019/11/20/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%9D%83%E8%A1%A1%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://lqczzz.github.io/2019/11/20/对数据系统架构设计权衡的思考/</id>
    <published>2019-11-20T03:04:32.000Z</published>
    <updated>2019-11-21T07:42:47.346Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在shopee参与feed项目设计和开发过程的一些思考。在feed系统设计中，很多设计算是实践了<a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener">《DDIA》</a>里面的一些论点。自认为《DDIA》中谈及的理论和在项目中得意实践其中的部分理论，让我在这两年里成长不少。</p><h2>一.什么是数据系统</h2><p>现在的互联网产品，大部分都可以归纳为是这样一种数据系统：它使用了多种数据存储系统：mysql/redis/kafka/es/hdfs涉及到关系数据库，缓存，消息队列，搜索引擎，分布式文件系统等等，如果需要推荐，还可能有hbase等数据存储工具，每种工具各司其职，分工合作，而代码更像是连接各个系统的粘合剂。</p><pre><code>                                                    api                                     +----------------------------------------------------+--------------------------------------+|                                                    |                                      ||      +-----------------+   read request  ....................       asyncjob              ||      | in-memory cache | --------------- . application code . ------------------+         ||      +--------+--------+ check if data   ....................                   |         ||               |          in cache first        |   | cache miss                 |         ||               |             +------------------+   | or writes                  |         ||               |             |search request        |                                      ||               |     +-------+--------+   +---------+--------+           +-------+------+  ||               |     |   full_text_q  |   |     primary db   |           |    message q |  ||               |     +-------+--------+   +---------+--------+           +-------+------+  ||               |             | sync to full text    | capture change             |         ||               |             +----------+-----------+                        +---+         ||               |                        |                                    |             ||               |   sync        ......................              ......................  |   |               +-------------- .  application code  .              .  application code  .  ||                               ......................              ......................  ||                                                                             |             |+-----------------------------------------------------------------------------+-------------+                                                                              |                                                                          thrid api  </code></pre><p>以twitter/weibo为代表的feed流产品就是这样一个典型的数据系统产品：它使用mysql/cassandra来持久化用户数据使用redis加速访问速度使用消息队列削峰填谷使用搜索引擎支持搜索特定用户/内容使用hbase等列式存储来做推荐/数据分析...</p><h2>二.数据系统系统设计方法论</h2><h3>2.0 数据系统设计方法和软件方法的收敛</h3><p>对于数据系统设计方法，先抛出结论：数据系统设计主要可以从三个角度给出问题，然后通过回答这些问题，基本可以得出一个比较合理的架构设计。</p><ol><li><p>数据模型数据的访问模式结构性/半结构性/非结构性局部性 or 多对多关系(访问)</p></li><li><p>系统负载读多写少(负载类型，读写扩散)..冷热数据(负载)..数据量..索引类型..</p></li><li><p>数据的正确性和时效性正确性：持久化保证正确性：一致性保证(限行一致性/顺序一致性/因果一致性...)时效性：低时效 == 最终一致</p></li></ol><p>除了上面的三个角度，其实还应该考虑上人的因素，比如团队对于某种数据系统的熟悉程度。</p><p>潘家宇的《软件方法》里提供了几个软件建模思路，大体上遵循</p><ol><li></li></ol><h3>2.1 数据模型和访问模式</h3><p>在思考数据模型的时候其实需要我们充分理解需求，抽象出领域模型，通过对象关系图(1:1/1:n/n:n)，正向反向关系等区分出核心数据模型和派生的数据模型</p><p>数据模型就是判断数据是属于结构性/半结构性还是非结构性(blob)blob数据不用说，大部分都是使用分布式文件系统存储半结构性数据，比如一则feed的json</p><pre><code>{    &quot;feedid&quot;: &quot;xx&quot;,    &quot;feed_uid&quot;: 123,    &quot;type&quot;: 1,    &quot;source: 2,    &quot;feed_username&quot;: &quot;&quot;,    &quot;content&quot;: {        &quot;voucher_stickers&quot;: [{        }],        &quot;caption&quot;: &quot;&quot;    },    &quot;comments&quot;: [{    }]}</code></pre><p>因为这种数据很少需要关联查询，很适合使用mongodb等文档结构模型数据库存储，也可以采用关系型数据库存储半结构性具有更加好的局部性，有利于一对多关系，不利于多对多关系，也容易造成冗余结构性（关系型）数据利于表示多对多关系，但是局部性更差</p><p>结构性数据库表可以使用一定的犯范式设计，提高了冗余，降低一致性，但是可以提高局部性。</p><p>在做feed需求里，明显feed数据更适合使用半结构化的数据库，比如mongodb/cassandra但是shopee历史原因只支持mysql/tidb做持久化的存储。所以我们的feed内容数据是以非范式化的方式存储在表个的一个字段里的。</p><h3>2.2 系统负载</h3><p>思考系统负载的时候其实就是思考系统的用例，系统需要对外提供哪些能力，这些接口具有哪些特性，核心难题在哪里这时候可以列出系统的关键接口，帮组我们思考。</p><h4>2.2.1 读负载类型还是写负载类型</h4><p>负载有很多种，互联网典型的是读多写少，读多，导致了索引计数的诞生b+树类型的索引的innodb很适合读多写少的场景，但是当读的负载更高，如读放大情况，光靠innodb也不行这时候需要redis做缓存。</p><p>但是使用缓存之后，一般需要代码里双写，那么是使用cache aside模式,是淘汰缓存，都是第三点：数据的正确性和时效性考虑的这里只是根据负载特性，确定需不需要引入缓存</p><h4>2.2.2 冷热数据</h4><p>有时候需要考虑热点数据问题，比如大v发文，评论点赞会比普通人更多，比如新旧数据，新的feed被访问概率大于旧的feed这些会影响到分表方式，kafka 分区数据等。</p><h4>2.2.3 数据量</h4><p>决定了分表的大小和缓存的开销</p><h4>2.2.4 索引</h4><p>选用什么类型的索引往往也是负载决定的，b+树/hash/lsm全文索引...</p><h3>2.3 数据的正确性和时效性</h3><p>数据的正确性和时效性其实算是CA(CAP)的一种选取,需要进一步考虑各个用例的流程图(时序图)。在分布式系统里，不可靠体现在：</p><ol><li>网络延迟</li><li>节点故障</li><li>网络超时</li></ol><p>其中网络超时是网络延迟的另一种形式，因为分布式系统里，识别异常通常通过超时机制来实现，而超时机制的缺点就是网络超时，此时你不知道请求是否成功到达了另一个节点。所以它是最麻烦的一种异常。因为种种的不确定性，我们可以使用逐步推断的方式建立一个正确的数据系统(如果一下子假设三种情况都成立，则考虑的分支太多，不利于思考)然后思考哪些一致性是需要得到保证的</p><h4>2.3.1 正确性</h4><p>如持久化保证顺序保证对于持久化也很重要比如CDC(change data capture)为核心的数据总线系统，使用binlog解析，导入kafka，消费者消费kafka到异构数据系统实现全文索引/推荐等功能，这时候，消息的顺序就显得很重要顺序可以通过id发号器来保证，分布式系统中，兰伯特时间序就是很重要的一个结论</p><h4>2.3.2 时效性</h4><p>只有强一致性才能保证实时生效，在异构系统里，时效性的保证需要牺牲性能。而且大部分业务场景其实并不需要这么强的时效性，这时候就需要做权衡了。</p><h2>三.举个栗子</h2><p>常见的社交场景中的点赞功能落地</p><h2>四.总结</h2><p>无论是分布式系统，还是其他架构的设计，都是一种权衡的艺术，分布式面临的很多问题其实在古老的操作系统，数据库中早就有了类似的场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章是在shopee参与feed项目设计和开发过程的一些思考。
在feed系统设计中，很多设计算是实践了&lt;a href=&quot;https://book.douban.com/subject/30329536/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://lqczzz.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构设计" scheme="http://lqczzz.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>动手写一个数据库(开篇)</title>
    <link href="http://lqczzz.github.io/2019/08/27/%E6%A0%91,%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://lqczzz.github.io/2019/08/27/树,文件系统和数据库/</id>
    <published>2019-08-27T03:04:32.000Z</published>
    <updated>2019-11-21T02:59:32.246Z</updated>
    
    <content type="html"><![CDATA[<p>最近打算通过手写一个数据库的方式，来达到掌握数据库的原理的目的，同时，以此为脉络，把数据库设计涉及的一些知识形成脉络，另外还对自己的薄弱的知识块进行查漏补缺，从初级开发到高级开发那些短板都能补齐。也不好承诺一周能拿出多少时间去做这个事情，毕竟身后已满是旗帜（flag）。一步步来吧，万丈高楼平地起嘛。</p><p>这篇笔记属于知识脉络梳理的，一方面可以让知识系统化，另一方面可以细化任务，让学习的目的和方向更清晰，更可控。</p><h3>stanford CS346</h3><p>stanford CS346 课程作业是实现一个简单的数据库系统，具体拆分为以下几步：</p><ol><li><p>RM（record manager 数据管理）</p></li><li><p>IX（index system）</p></li><li><p>SM（system manager）</p></li><li><p>QL（sql 查询语言实现）</p></li><li><p>EX（选一个方向然后实现）</p></li></ol><p>这篇笔记算是对RM和IX的抛砖引玉。</p><h2><strong>数据库的诞生和发展</strong></h2><p>鲁迅说过，计算机主要完成两件事：计算和存储（鲁迅：那是周树人说的与我何干）。翻阅图灵奖的历史，至今有四位图灵奖获得者因为在数据库领域的杰出贡献而获奖，足以见得，数据库诞生的重要意义。</p><p>1956年，在计算机诞生将近20年的时候，IBM公司成功推出磁盘存储方案，相较于在那之间的磁带技术，磁盘<strong>支持随机读取，容量大</strong>，计算机开始逐渐活跃在数据处理领域。最开始，数据处理软件只有文件管理，后来出现了文件系统，但是磁盘的数据冗余问题非常严重，据说阿波罗登月计划用的磁盘有60%以上是冗余数据，后来，一个老家伙倒腾出了网状数据库，并且于1971年推动CODASYL提出了DTBG模型，直接影响了后续的数据库技术，同年，unix的缔造者们开始撸unix-kernal，<strong>数据库的诞生完全和操作系统是同时进行的</strong>。</p><p>注意，<strong>数据库最初的诞生完全是为了解决磁盘数据冗余的问题</strong>！！所以wangyin在<a href="http://www.yinwang.org/blog-cn/2014/04/24/relational" target="_blank" rel="noopener">关系式模型的实质</a>对数据库和关系模型的吐槽显得站不住脚，当然不是说他说的东西有问题，他说关系模型表现力不如基础的数据结构，说查询语言，sql，cyber之类的不如普通的编程语言，这当然是在扯淡了。</p><ol><li>关系模型只能等价于别的数据结构，比如用关系模型去模拟1:1/1:m/n:m关系都是ojbk的。</li><li>sql，cypher之类的语言本身是图灵不完备的语言，编程语言基本上都是图灵完备的语言，表现力不足不是板上钉钉的吗？</li></ol><p>用今天的观点去看待历史，批评数据库，关系模型，何不食肉糜？</p><h2>数据库和文件系统</h2><p>CS346在RM一节中的任务主要介绍了</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PF_Manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">       PF_Manager    ();                           <span class="comment">// Constructor</span></span><br><span class="line">       ~PF_Manager   ();                           <span class="comment">// Destructor</span></span><br><span class="line">    <span class="function">RC <span class="title">CreateFile</span>    <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span></span>;       <span class="comment">// Create a new file</span></span><br><span class="line">    <span class="function">RC <span class="title">DestroyFile</span>   <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span></span>;       <span class="comment">// Destroy a file</span></span><br><span class="line">    <span class="function">RC <span class="title">OpenFile</span>      <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName, PF_FileHandle &amp;fileHandle)</span></span>;  </span><br><span class="line">                                                   <span class="comment">// Open a file</span></span><br><span class="line">    <span class="function">RC <span class="title">CloseFile</span>     <span class="params">(PF_FileHandle &amp;fileHandle)</span></span>;  <span class="comment">// Close a file</span></span><br><span class="line">    <span class="function">RC <span class="title">AllocateBlock</span> <span class="params">(<span class="keyword">char</span> *&amp;buffer)</span></span>;              <span class="comment">// Allocate a new scratch page in buffer</span></span><br><span class="line">    <span class="function">RC <span class="title">DisposeBlock</span>  <span class="params">(<span class="keyword">char</span> *buffer)</span></span>;               <span class="comment">// Dispose of a scratch page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2>数据库和树</h2><p>参考资料：</p><p>《图灵和ACM图灵奖》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近打算通过手写一个数据库的方式，来达到掌握数据库的原理的目的，同时，以此为脉络，把数据库设计涉及的一些知识形成脉络，另外还对自己的薄弱的知识块进行查漏补缺，从初级开发到高级开发那些短板都能补齐。也不好承诺一周能拿出多少时间去做这个事情，毕竟身后已满是旗帜（flag）。一步
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://lqczzz.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>一个入行两年的菜鸟程序员的思考</title>
    <link href="http://lqczzz.github.io/2019/08/17/%E4%B8%80%E4%B8%AA%E5%85%A5%E8%A1%8C%E4%B8%A4%E5%B9%B4%E7%9A%84%E8%8F%9C%E9%B8%9F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E8%80%83%20/"/>
    <id>http://lqczzz.github.io/2019/08/17/一个入行两年的菜鸟程序员的思考 /</id>
    <published>2019-08-16T17:45:32.000Z</published>
    <updated>2019-08-17T02:37:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2>前面的话</h2><p>从6月到8月，feed着手timeline的优化和新需求开发。从开始的轻松从容，到后来的逐渐失控。实际上，一个仿造的“人月神话”悄悄来到了我的身边。其中有很多值得反思和总结的地方。希望趁现在处于羞耻，自责和焦虑中，思考和总结点东西，一方面希望能够总结出一些自己受用的一些规则和教训，对以后成长更有帮助。另一方面，希望能借此透过现象看本质，穿越流于表面的情绪看到问题的本质，真正的获得成长。</p><h2>需求之坑</h2><p>在做feed之前，我也曾经被需求弄的很头疼，但是当时自己并没有很重视，而是单纯的归因到团队里去。在华为正式工作的时候，因为在预研部门，项目流程不是很规范，直接leader是项目管理和人员管理的，需求是由另一个领导直接提的。</p><blockquote><p>需求不是架构，需求不是设计也不是用户界面，需求是需要 —— 《程序员修炼之道》</p></blockquote><p>在华为的时候，我们得到的并不是真正的需求，只是用户(leader)的模糊的需要。这种需要没有形成需求文档，产品设计文档，没有ui去描绘用户界面。还是初入职场的菜鸟的我那时候也不懂得《程序员修炼之道》里面的真知灼见，单纯的归因为团队的不规范，却又说不出具体怎么的不规范，归因为自己的技术水平但事实上，导致项目失败的原因，技术水平只占了不到1%。</p><p>来到shopee，leader是在微信和产品经理斗智斗勇多年的老司机，他用他的经验告诉我们，开发要站在用户的角度思考问题，要评估需求的合理性.另一方面，这边的产品经理也显得更加正规靠谱，毕竟是阿里头条挖过来的。</p><blockquote><p>与用户一同工作，以像用户一样思考 —— 《程序员修炼之道》</p></blockquote><p>正是这些，导致我再一次忽略了对需求的思考。也许我用leader那拾人牙慧的学习到了一点需求的经验。但是并没有形成自己的一套方法。</p><p>先抛出我作为一个开发者对需求评估的工作流总结：</p><h3>不要搜集需求，要挖掘需求</h3><p>《程序员修炼之道》里给了一个典型的例子：&quot;只有员工的上级和人事部们可以查看员工的档案&quot;是需求吗。转换一下：只有获得授权的用户才可以访问员工档案。两种陈述对于实现来说是截然不同的。</p><p>这一点通常主要是产品的工作，但是开发从产品和用户角度去思考需求产生的原因，往往更能把控实现这件事情的方式。典型的例子是对于这一次开放用户白名单给非kol的商家的需求，PM提出来之后我马上就思考现有的实现细节，没有先分析需求提出来的原因，或者说思考的不够认真，只是流于表面的认为这个只是为了紧急支持local的99促销活动。如果我再进一步的思考，我应该去思考为什么现有的系统不能做，怎么做更佳合理。最终导致自己加班加点的去做需求。</p><h3>需求文档的坑</h3><p>同上，这个也主要是PM的工作，但是需求文档是PM和开发的接口文档，对于开发来说，分析需求文档，建立用例图，然后通过沟通和PM澄清需求，是开发前期最重要的一个阶段。</p><p>在我们的系统中，需求文档主要有两个问题：</p><ol><li>需求文档变更，我们经常抱怨需求文档变化，一方面是需求下来的时候可能比较紧急，文档确实不够详细，另一方面，这是需求文档本来的&quot;原罪&quot;，我们只是没有认识到这一点而已。</li></ol><blockquote><p>制作需求文档的一大危险是太过具体，好的需求文档会保持抽象，需求文档能准确反映商业需求 — 《程序员修炼之道》</p></blockquote><p>在multitabs的需求中，我承认自己对需求文档不够重视，没有仔细斟酌里面的描述，缺少在写代码前和PM的交流，澄清需求，为了逃避交流自己做了太多假设。交流产生的结果也没有准确写入到PRD或者自己的需求规约汇中。这是自己给自己埋下的第一个坑。</p><h3></h3><h2>进度管理</h2><p>人月神话在&quot;系统测试&quot;一节给出了一个软件任务进度安排的经验法则：</p><ul><li><p>1/3 计划</p></li><li><p>1/6 编码</p></li><li><p>1/4 构建测试和早期系统测试</p></li><li><p>1/4 系统测试，所有构件完成</p></li></ul><p>在我看来，这些比例也并非一成不变的，但是更多的东西我没有足够的重视，或者没有足够的经验去思考出自己的一套需求开发进度安排和任务工作量估算的方式。经过一年多的踩坑，我终于认识到，进度管理真的不仅仅是leader的事情，也许我们只需要管理好一部分进度，但是进度管理的基本方法论是不变的。</p><h3>计划</h3><p>计划这一阶段应该在需求评审会的时候，明确好以下的一些东西。</p><ol><li>任务</li><li>责任人</li><li>进度</li><li>接口定义</li></ol><h3>设计和编码的分离</h3><p>首先一点我没有清晰的认识的是，计划和编码是具有清晰明确的边界的。而且计划的时间一定比编码长。在feed项目之初或者至今，我都没有很好的平衡这两点。系统时序图对于思考编码的实现，业务流程是很好的工具，可以当作设计阶段的一个很好的形式化工具，类似于vscode之于编码，系统时序图就是设计阶段的工作。</p><p>设计工作量永远大于编码，除非是一个需求很清晰，实现很清晰，代码量不足50行的需求，否则我都应该在编码之前，在草稿纸上，画出一个简单的设计。更加复杂的需求，就要借助startuml工具(puml)来完成了。</p><h3>外部依赖管理</h3><p>一个0.5天工作量的需求，往往具有的特点是：</p><ol><li>不存在外部依赖</li><li>代码修改量少于50行</li></ol><p>存在外部依赖的时候，即使条件2满足了，也不能乐观的认为工作量只有0.5天完事，《人月神话》里，对于职业的苦恼，有一点正是说的——</p><blockquote><p>&quot;苦恼来自由他人设定目标，供给资源和提供信息&quot;</p></blockquote><p>推荐团队是我见过的最恶劣的合作团队，不仅仅无限延期对接的接口，给出的接口竟然能不按照穿进去的分页参数去返回结果。这也让我认识到，外部依赖永远都是不可靠的。</p><p>不仅仅是团队，内部的依赖往往也不可靠，比如你永远不清楚，一个别人定义的delexxx方法，究竟在实现里面会不会带有副作用。</p><p>在有外部依赖的情况下，工作量都需要按照1天起估算，主要是因为，对于外部依赖，需要有充足的系统测试时间。另外，当一个需求实现的工作量时间大于两天，往往需要再细分到更小的粒度，不然很容易导致失控，或者在遇到困难的时候，没办法让别人更好的参与进来一起解决。</p><h2>设计之坑</h2><h3>初级设计之坑</h3><p>用华为的等级来看，能不能掌握避开初级设计之坑的方法，是13级和14级的区别。13级基本不需要设计，按照既定的规范来做就好，14级开始要做初级设计，接口文档，系统设计之类的。不再埋头编码，是一个准备入行的菜鸟和已入行的弱鸡的区别。</p><p>设计阶段，有两个坑：</p><ol><li>不知道抓重点</li><li>不知道使用什么工具／流程图表达</li></ol><p>第1点在去年的时候我也没有清晰的认识，但是今年看完《DDIA》，结合一些实践上的思考，得出一些自己的经验规律。</p><p>比如对于接口，或者系统设计，我们首先要明确好负载，负载可能是一个高并发场景下的QPS这个指标，也可能是feed关注关系的读写扩散导致的读写放大。之后要明确好性能，性能主要是响应时间等一些我们期望达到的目标。抓重点首先要简化需求模型，脑海里有一个MVP（最小可行性）模型，方便我们对症下药。</p><p>不知道使用什么工具，一方面可能是我们对于软件开发的众多UML工具没有一个系统的了解。但是在学习完《软件方法》课程之后，其实就不太应该了。我觉得，最应该熟悉的是：</p><ol><li><p>用例图</p></li><li><p>系统时序图</p></li></ol><p>其他的都是用的时候再去思考哪种合适就好，永远都不要做工具的奴隶，拿起锤子，看到什么都是钉子。</p><h3>高级设计之坑</h3><p>在华为我见过最厉害的14级的设计，也很少去很好的思考以下的一些问题：</p><ol><li><p>责任是否得到了良好的定义</p></li><li><p>协作是否得到了良好的定义</p></li><li><p>耦合是否得以最小化</p></li><li><p>接口定义和各项约束是否可接受</p></li></ol><p>这些都涉及一定的经验和一定的技术直觉。经验有得到需要的是3年／5年，对于善于思考的人，往往更短。</p><blockquote><p>实践是最好的老师，但智者还能从其他的地方有所收获 — 《穷查理年鉴》</p></blockquote><p>我们可以在自己的设计和别人的设计中不断思考反思上面的4点是如何迭代实现的。在学习开源框架中学习如何抽象对象和结构，在业务开发中，更佳灵活的根据各种需求来进行设计，把阅读开源代码学习到设计灵活应用起来，这样才能真正转化为自己的东西。</p><p>技术直觉需要源源不断的学习，保持好奇心，保持兴趣。</p><p>比如通过DDIA对数据系统的高屋建瓴般的总结，从而对常用的中间件建立一定的技术直觉。</p><p>当然，好奇心和兴趣往往因为压力打压变小，这种时候就该反思自己最近一段时间的状态了。而不是把这种状态视为理所当然。不要逃避问题，否则只能遭致更大的问题。</p><h2>总结和勉励</h2><p>有时候，心里总会有这样的一个声音反复问自己：&quot;为什么要总结这些东西，再怎么总结，以自己的经验，都是做不到比书本更完美的&quot;。我想，有了两年的工作经验之后的今年，我终于找到了原因：</p><blockquote><p>不把信息当知识，不把收藏当学习，不把阅读当思考，不把存储当掌握</p></blockquote><p>当我们生搬硬套教科书的知识／别人的经验，那是永远都没有真正去掌握并转化为自己的能力的。</p><ul><li>比如网络5层协议没有生搬硬套OSI7层网络模型</li><li>比如东施效颦</li></ul><p>编码工作是理性的，枯燥和创造性并存，让其成为近百年来改变世界最明显的工作的原因，正是千百年来无数数学家思考的结晶。很多东西和生活也是相通的，比如生活中怎么管理好大大小小的事情，和项目管理也没啥区别。</p><p>愿我能继续拥有感性的精神世界，理性的生活方式。继续矫情下去，但是也能理性的去掌控好自己的生活。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;从6月到8月，feed着手timeline的优化和新需求开发。从开始的轻松从容，到后来的逐渐失控。实际上，一个仿造的“人月神话”悄悄来到了我的身边。其中有很多值得反思和总结的地方。希望趁现在处于羞耻，自责和焦虑中，思考和总结点东西，一方面希望能够
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式系统入门</title>
    <link href="http://lqczzz.github.io/2019/01/06/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://lqczzz.github.io/2019/01/06/分布式系统入门/</id>
    <published>2019-01-06T12:26:51.000Z</published>
    <updated>2019-03-15T17:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1>分布式基础</h1><p>本文主要是<a href="http://book.mixu.net/distsys/ebook.html#abstractions" target="_blank" rel="noopener">《Distributed systems for fun and profit》</a>的笔记</p><h2>一.基础</h2><p>计算机主要做两个事情：</p><ol><li>计算</li><li>存储</li></ol><h3>1. 为什么要用分布式系统</h3><p>当单台机器的硬件升级也没法解决问题的时候，就需要分布式系统。理论上来说，添加一个服务节点可以线性提升性能，但是现实中，多台机器还涉及到数据拷贝，任务合作等问题。</p><h4>1.1 目标</h4><p>分布式系统，我们想要：<strong>可扩展性</strong>——数据或者问题规模变大，可以单纯的通过增加节点解决。</p><p>扩展性，就要求规模，节点规模从小到大，就会遇到以下问题：</p><ol><li><p>性能</p><ul><li>低时延</li><li>高吞吐</li><li>资源消耗低</li></ul></li><li><p>可用</p><ul><li>容错性：允许某些节点失败</li><li>延时不能过高</li><li><code>Availability = uptime / (uptime + downtime)</code></li></ul><table><thead><tr><th>Availability %</th><th>How much downtime is allowed per year?</th></tr></thead><tbody><tr><td>90% (&quot;one nine&quot;)</td><td>More than a month</td></tr><tr><td>99% (&quot;two nines&quot;)</td><td>Less than 4 days</td></tr><tr><td>99.9% (&quot;three nines&quot;)</td><td>Less than 9 hours</td></tr><tr><td>99.99% (&quot;four nines&quot;)</td><td>Less than an hour</td></tr><tr><td>99.999% (&quot;five nines&quot;)</td><td>~ 5 minutes</td></tr><tr><td>99.9999% (&quot;six nines&quot;)</td><td>~ 31 seconds</td></tr></tbody></table></li></ol><h4>1.2 阻碍</h4><ol><li>节点数量</li><li>节点的距离</li></ol><p>光速传播速度和cpu频率决定了最低时延</p><h3>2. 如何研究分布式系统</h3><h4>2.1 抽象和模型</h4><p><strong>抽象</strong>可以从现实世界的复杂中得到本质的东西，这种本质就是<strong>模型</strong></p><p>分布式系统的本质可以归纳为三个模型：</p><ol><li>系统模型（同步／异步）</li><li>容错模型（crash-fail/partition/拜占庭问题）</li><li>一致性模型（强一致／弱一致）</li></ol><p>抽象的目的就是为了让这个系统对外看起来像是一个节点。这里有一个矛盾，过分强调一致，会使得使用者容易理解，但是会导致性能不好，可用性降低，适当暴露一些细节会提高性能，但是增加了系统的理解成本。</p><h3>3 分布式实现</h3><p>本质上只有两种手段：</p><ol><li>数据分区（partition）</li><li>数据复制（replication）</li></ol><p><img src="http://book.mixu.net/distsys/images/part-repl.png" alt="partition/replication"></p><p><strong>partition</strong>可以把数据分成几块，解决了单一节点的存储限制</p><p><strong>replication</strong>允许我们实现可扩展，容错，但是涉及到数据的同步，是很多问题的源泉，<strong>一致性模型</strong>就是为了描述这个问题而存在的</p><h2>二.理论</h2><p>抽象可以提取实物的本质，再通过这个本质可以推导出某种公理性的东西</p><p>系统模型就是分布式系统的抽象</p><h3>1. 系统模型</h3><p>分布式系统模型的抽象取决于假设的多少，一般来说，假设越少越好，系统模型有三个基本的假设</p><ol><li>节点独立运行</li><li>节点通过网络连接</li><li>节点之间的内存和时钟不共享</li></ol><p>假设越少，推演出来的理论和算法的适用范围越广，如增加假设：<code>节点从来不会失灵</code>，则推演出来的算法会忽略掉节点失灵的错误处理，系统就会变得不健壮。</p><p>关于节点——节点提供了：</p><ul><li>可执行程序</li><li>数据存储到内存和磁盘</li><li>本地时钟</li></ul><p>节点的状态：</p><ul><li>失灵（fail）</li><li>crash</li><li>拜占庭将军问题：(叛徒)</li></ul><p>节点通信的两种异常：左边是节点失灵，右边是网络</p><p><img src="http://book.mixu.net/distsys/images/system-of-2.png" alt="node"></p><h3>2. 公理</h3><p>有了系统模型，我们推演出了一些公理</p><h4>2.1 FLP理论</h4><p>假设：</p><ul><li>节点 Fail by crash （不会出现拜占庭将军问题）</li><li>网络可靠</li><li>异步系统模型 消息可能无限delay</li></ul><p>结论</p><p>​在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性</p><blockquote><p>证明见参考</p></blockquote><h4>2.2 CAP理论</h4><p><img src="http://book.mixu.net/distsys/images/CAP.png" alt="cap"></p><ul><li>consistency:  所有节点在同一时刻看到同样的值</li><li>availability：某些节点失效并不影响剩余节点运行</li><li>Partition tolerance：即使因为网络分割或者节点失效造成的消息丢失，系统正常运行</li></ul><p>同时满足三个性质的系统是不存在的。</p><p>比如你要强一致，并且保证高可用性，任何节点失效系统都不失效，那么对网络分割就没办法容忍了，每条消息都不能丢失。</p><ul><li>CA（Consistency + Availability）如two-phase commit</li><li>CP（Consistency + Partition tolerance）如Paxos，raft</li><li>AP (Availibity + Partition tolerance) 弱一致系统，如gossip</li></ul><p>通常，分布式系统我们需要保证P，所以要在CA作取舍</p><blockquote><p>实践中我们大多已经采取了弱一致性的异步延时同步方案，以提高可用性</p></blockquote><h5>2.2.1 一致性的扩展</h5><p>这里，CAP的C理解为多个数据副本的读写一致性问题，其实C可以在很多场景拓展</p><ul><li>多个数据副本的读写</li><li>事务</li><li>关联</li></ul><p>关系数据库关于事务操作，必须遵循ACID原则：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）和持久性（Durability）</p><p>这里的C表示一个事务中多个操作成功失败是一致的。</p><blockquote><p>众所周知，分布式事务一般采用两阶段提交策略来实现，这是一个非常耗时的复杂过程，会严重影响系统效率，在实践中我们尽量避免使用它。在实践过程中，如果我们为了扩展数据容量将数据分布式存储，而事务的要求又完全不能降低。那么，系统的可用性一定会大大降低，在现实中我们一般都采用对这些数据不分散存储的策略。</p></blockquote><p>nosql数据库为了实现P，牺牲了C，也即牺牲了事务，事务遵循<em>BASE</em>而不是<em>ACID</em></p><h2>三.时间和顺序</h2><h4>3.1 全序和偏序</h4><p>全序就是在集合里任何两个元素都可以比较，分出大小。偏序中，某些元素是没办法比较大小的。</p><p>在分布式的系统里，每个节点的指令运行顺序都取决于本地节点的时钟，所以分布式系统是偏序。</p><h4>3.2 时间匀速流逝</h4><p>时间是顺序的来源，分布式系统中每个节点都有独立的本地时间和时间戳，于是事件的发生有本地的顺序，但是该顺序和其他节点完全独立，很难做到全部节点有序。当然也不是做不到全序，维持一个全局时钟就是一种方法，只是这种方法的代价太大。</p><ul><li>全局时钟（Global Clock）</li><li>本地时钟（Local Clock）</li><li>没有时钟存在（No Clock）</li></ul><h5>3.2.1 全局时钟</h5><p><img src="http://book.mixu.net/distsys/images/global-clock.png" alt="全局时钟"></p><p>完美的时钟，走时同步，存在于所有节点。这是分布式系统的理想假设。实际上，时钟同步只能保证有限的精度。用户可能随机地改变本机时间，新节点加入，都有可能破坏全局时钟的假设。</p><blockquote><p>现实系统也有做出这个假设的。FB的Cassandra，就是使用时间戳来解决write的冲突的</p></blockquote><h5>3.2.2 本地时钟</h5><p><img src="http://book.mixu.net/distsys/images/local-clock.png" alt="local clock"></p><p>本地时钟无法保证全局有序</p><h5>3.2.3 没有时钟</h5><p>完全不使用”时钟”这个概念，取而代之，“逻辑时间”。因为时间戳么，只不过是当前世界状态的一个快照，那我们用一个计数器（Counter），并和节点之间交流就可以做到了。</p><p>这样，我们可以在不同的节点之间决定事件顺序。不过有个坏处，因为缺乏时钟，没办法决定timeout。</p><p>“没有时钟”的假设的实现有：</p><ol><li><p>Lamport时钟</p></li><li><p>Vector clocks</p></li></ol><blockquote><p>Cassandra的cousin Riak 和 Vodemort（LinkedIn）是它的应用。这些系统避免了全局or本地时钟漂移带来的不确定性。</p></blockquote><h5>3.2.4 逻辑时钟</h5><p><strong>Lamport时钟</strong>和<strong>向量时钟</strong>通过计数器和通信来决定分布式系统中事件发生顺序的。计数器可以在不同节点之前进行比较。</p><h6>3.2.4.1 Lamport时钟</h6><p>每个进程都维护一个计时器。</p><ul><li>当进程做了任意一件事，增加计时器计数。</li><li>进程发送的消息中包含计时器计数。</li><li>当收到消息以后，计数器设置如下：max(local_counter, received_counter) + 1</li></ul><p>Lamport时钟定义了一个偏序，如果 timestamp(a) &lt; timestamp(b):</p><ul><li>a 可能发生在b之前</li><li>a和b压根没法比较</li></ul><p>第二种情况发生在a和b所在的Partition没有发送通信。</p><h6>3.2.4.2 Vector clocks</h6><p>向量时钟是Lamport时钟的一种扩展。它维护大小为N的数列[t1, t2, ....]，N为节点数。每个节点都更新自己的时钟。</p><ul><li>每当进程做了事情，更新该node的时钟。</li><li>进程发送的消息，包含上面提到的数组。</li><li>当收到消息以后，更新本地的数组里面的每个元素max(local, received)；为当前节点的counter加1</li></ul><p>如图：</p><p><img src="http://book.mixu.net/distsys/images/vector_clock.svg.png" alt=""></p><h4>3.3 失灵检测</h4><p>对于一个节点上的程序，它怎么知道远程某个节点失效了呢？在缺乏有效准确的全局信息下，我们可以通过一个合理的timeout值来确定。但是合理的timeout值该怎么确定呢？</p><p>失灵检测器可以通过使用心跳消息来实现timeout。节点之间交换心跳消息。如果消息在timeout之前没有收到响应，就可以认为出现失效。这种检测要么太冲动(把正常的节点算成失效），要么太保守，很长时间才能检测出错误。</p><p><a href="http://www.google.com/search?q=Unreliable%20Failure%20Detectors%20for%20Reliable%20Distributed%20Systems" target="_blank" rel="noopener">论文</a> 讨论了失灵检测在解决一致性问题中的两大属性：<strong>完整性</strong>和<strong>精准性</strong></p><h4>3.4 总结</h4><p>在分布式系统中应假设偏序而不是全序。而要承诺全序也是可能的，但是代价非常大。</p><p>时间，顺序和同步真的必要么？看情况。有时候可能你只不过需要最后的结果而不关系中间事件发生的顺序。</p><h2>四.replication</h2><p>拷贝其实是一组通信问题，为一些子问题，例如选举，失灵检测，一致性和原子广播提供了上下文</p><p>拷贝本质就只有两种：</p><ol><li>同步拷贝</li><li>异步拷贝</li></ol><h4>4.1 拷贝范式</h4><h5>4.1.1 同步拷贝</h5><p><img src="http://book.mixu.net/distsys/images/replication-sync.png" alt=""></p><p>首先client发送请求。然后同步拷贝，同步意味着这时候client还在等待着请求返回。最后，服务器返回。</p><p>这就是N-of-N write，只有等所有N个节点成功写，才返回写成功给client。系统不容忍任何服务器下线。从性能上说，最慢的服务器决定了写的速度</p><h5>4.1.2 异步拷贝</h5><p><img src="http://book.mixu.net/distsys/images/replication-async.png" alt=""></p><p>master节点立即返回。该节点可能在本地做了复制，但是不会向其他服务器发送拷贝。只有在返回以后，异步的任务在开始执行。</p><p>相对地，这是1-of-N write。性能上说，快。但是不能提供强一致性保证。</p><h4>4.2 拷贝算法</h4><h5>4.2.1 overview</h5><p>一致性的强弱可以用来区分拷贝算法</p><blockquote><p>一致性就是所有的节点都同意某一个值，具体的说，一致性包括：</p><p>协议：每个正确的流程必须就相同的价值达成一致。完整性：每个正确的过程最多决定一个值，如果它决定某个值，那么它必须由某个过程提出。终止：所有流程最终都会做出决定。有效性：如果所有正确的过程提出相同的值V，那么所有正确的过程决定V</p></blockquote><p>互斥，leader选举，多播和原子广播都是更普遍的一致性问题</p><p>单拷贝系统按照一次执行中传递的消息数目，可以做一下分类：</p><ul><li>1n messages（异步 主从备份）</li><li>2n messages（同步 主从备份）</li><li>4n messages（2-phase commit，Multi-Paxos)</li><li>6n messages （3-phase commit，Paxos with repeated leader election）</li></ul><p><img src="http://book.mixu.net/distsys/images/google-transact09.png" alt=""></p><p>上图列出的复制算法不难发现，一致性强的算法，相应的延时高，性能低，这是一种取舍，得此失彼。</p><h5>4.2.2 主从备份拷贝</h5><p>最常见最基本的拷贝方式。所有的update发生在primary，并且以log的形式拷贝到backup 服务器。主从备份也分同步和异步两种。</p><p>MySQL和MongoDB都使用异步主从备份。同步主从备份保证在返回给client之前，backup节点成功存储了拷贝（Replica）。不过即使这样，同步方式也仅能保证较弱的承诺。考虑下面的场景：</p><ul><li>主服务器收到write，发送到backup</li><li>backup 写成功。返回ACK</li><li>主服务器fail，client超时，认为写失败。</li></ul><p>client现在认为写失败，但是backup其实成功。如果backup promote成为primary，那么就不对了</p><h5>4.2.3 两阶段提交（2PC）</h5><p>2PC在很多经典的关系型数据库中都使用到了。例如MySQL 集群使用2PC提供同步拷贝。下面是2PC的基本流程</p><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ Coordinator ] -&gt; OK to commit?     [ Peers ]</span><br><span class="line">                &lt;- Yes / No</span><br><span class="line"></span><br><span class="line">[ Coordinator ] -&gt; Commit / Rollback [ Peers ]</span><br><span class="line">                &lt;- ACK</span><br></pre></td></tr></table></figure></p><p>在第一阶段，<strong>投票</strong>，协调者（Coordinator）给所有参与者发送update。每个参与者投票决定是否commit。如果选择commit，结果首先存放在临时区域（the write-ahead log）。除非第二阶段完成，这部分都只算“临时”的update。</p><p>在第二阶段，<strong>决策</strong>，协调者决定结果，并通知参与者。如果所有参与者都选择commit，那结果从临时区域移除，而成为最终结果。</p><p>2PC在最后commit之前，有一个临时区域，就能够在节点失效的时候，从而允许回滚。</p><p>之前讨论过，2PC属于CA，所以它没有考虑网络分割，对网络分割并没有容错。同时由于是N-of-N write，所以性能上会有一些折扣</p><h5>4.2.4 对网络分割容错的一致性算法：gossip/raft和ZAB</h5><p>对网络分割容错的一致性算法其实就是实现了CAP的CP，同时保重了一定的A。</p><h6>什么是网络分割（Network Partition）</h6><p>节点本身正常运行，但是网络链路发生问题。不同的Partition甚至还能接收client的请求。</p><p>2节点，节点失效 vs 网络分割</p><p><img src="http://book.mixu.net/distsys/images/system-of-2.png" alt=""></p><p>3节点，节点失效 vs网络分割</p><p><img src="http://book.mixu.net/distsys/images/system-of-3.png" alt=""></p><p><strong>对这类算法会在学习MIT6.824公开课深入学习，to be continues...</strong></p><h4>4.3 总结</h4><p>总结下各类算法的一些关键特征。</p><p><strong>主从备份</strong></p><ul><li>单独的，静态的master节点</li><li>复制日志，slaves节点并不参与执行具体操作</li><li>拷贝操作的延时没有上限</li><li>无法容错网络分割</li><li>在不一致和错误发生情况下，需要手工干涉</li></ul><p><strong>2PC</strong></p><ul><li>统一投票：提交或者放弃</li><li>静态的master节点</li><li>协调者和普通节点同时挂掉情况下无法保证一致性</li><li>无法容错网络分割</li></ul><p><strong>Paxos like</strong></p><ul><li><p>多数投票</p></li><li><p>动态master节点</p></li><li><p>允许n/2-1节点挂</p></li><li><p>对延时并不太敏感</p></li></ul><h2>遗留的问题</h2><ol><li>拜占庭将军问题</li><li>2PC</li><li>flp实现</li></ol><h2>参考</h2><p><a href="http://book.mixu.net/distsys/ebook.html#abstractions" target="_blank" rel="noopener">1. ebook</a></p><p><a href="https://zhuanlan.zhihu.com/p/41329283" target="_blank" rel="noopener">2. 区块链时代的拜占庭将军们</a></p><p><a href="https://blog.csdn.net/chen77716/article/details/27963079" target="_blank" rel="noopener">3. FLP impossible</a></p><p><a href="https://www.jdon.com/bigdata/how-to-understand-cap.html" target="_blank" rel="noopener">4. 如何正确理解CAP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;分布式基础&lt;/h1&gt;
&lt;p&gt;本文主要是&lt;a href=&quot;http://book.mixu.net/distsys/ebook.html#abstractions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Distributed systems fo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>怎样设计golang友好的api</title>
    <link href="http://lqczzz.github.io/2018/12/24/%E6%80%8E%E6%A0%B7%E8%AE%BE%E8%AE%A1golang%E5%8F%8B%E5%A5%BD%E7%9A%84api/"/>
    <id>http://lqczzz.github.io/2018/12/24/怎样设计golang友好的api/</id>
    <published>2018-12-23T17:08:47.000Z</published>
    <updated>2018-12-23T17:13:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是Dave Cheney在2014年发表的，我认为在go语言的接口设计上，这篇文章起到了指明灯的作用，包括Micro在内的框架，都使用了这种方式提供API。原文看这里</p><p>正文开始：</p><p>下面的内容是我的一次演示的文字版本，这是我在dotGo上演讲的『Functional options for friendly APIs』，在这里已经编辑的可读了。</p><p><img src="http://btfak.com/images/api-design1.png" alt="">我想用一个故事作为开头。</p><p>在2014年的晚些时候，你的公司发布了一款革命性的分布式社交网络工具，很明智的，你选择了Go来开发你的产品。</p><p>你分配到的任务是编写极为重要的服务端组件，看起来可能像这样</p><p><img src="http://btfak.com/images/api-design2.png" alt=""></p><p>这里有一些不可导出的字段需要初始化，通过一个goroutine运行起来，响应请求。</p><p>这个包有很简单的API，非常容易使用。</p><p>但有一个问题，当你发布了你的第一个版本后，新的需求不断的被提出来。</p><p><img src="http://btfak.com/images/api-design3.png" alt=""></p><p>手机客户端经常是响应的很慢，甚至停止响应。你需要添加支持来对慢的客户端主动断开连接。</p><p>为了增加安全，新的需求是增加安全连接（TLS）。</p><p>然后，你的某些用户是在一个很小的服务器上运行服务，他们需要限制客户端数量的方式。</p><p>下面是想要对并发数进行限制。</p><p>不断的新需求…</p><p>限制你需要调整你的API来满足这一系列的新需求</p><p><img src="http://btfak.com/images/api-design4.png" alt=""></p><p>还需要考虑不同版本直接接口的兼容性问题。</p><p>实话说，谁用过这样的API？</p><p>谁编写过这样的API?</p><p>谁的代码以为依赖了这样的包，而不能正常使用了？</p><p>明显的这种解决方式是笨重而脆弱的，同时也不容易发现问题。</p><p>你的包的新用户，不知道哪些参数是可选的，哪些是必须的。</p><p>比如说，如果我想创建一个服务的实例作为测试，我需要提供一个真实的TLS证书吗，如果不需要，我需要在接口中提供什么？</p><p>如果我不关心最大连接数，或者最大并发数，我应该在参数中设置什么值，我应该使用0？0听起来是合理的，但这依赖于具体的接口是怎样实现的，这也许真的会导致并发数限制为0。</p><p>在我看来，这样写API是容易的，同时你把正确使用接口的责任抛给了使用者。</p><p>这个例子甚至代码写的很糟糕，文档也不友好，我想这示范了一个看起来华丽，其实很脆弱的API设计。</p><p>现在我们定位了问题，我们看看解决方案。</p><p><img src="http://btfak.com/images/api-design5.png" alt=""></p><p>与其提供一个单独的接口处理多种情况，一种解决方案是提供一系列的接口。</p><p>用户按需调用即可。</p><p>但你很快会发现，提供如此大量的接口，很快会让你不堪重负。</p><p>让我们看看另一种方式。</p><p><img src="http://btfak.com/images/api-design6.png" alt=""></p><p>一种非常简单的方式是提供一个配置结构体。</p><p>这有一些优势。</p><p>使用这种方式，如果有新的需求加入，在结构体中增加选项即可。对外的公共API仍然保持不变。这也能让文档更加友好、可读。</p><p>在结构体上注明这是NewServer的参数，文档上也很容易识别。</p><p>潜在的它也允许用户使用0作为参数的值。</p><p><img src="http://btfak.com/images/api-design7.png" alt=""></p><p>但是这种模式并不完美。</p><p>对于默认值是有歧义的，特别是0的值如果有特别的含义。</p><p>比如在这里的配置结构中，如果port没有被设置，NewServer会监听8080端口。</p><p>但是这有一个负面影响，你也许想设置为0，然后服务端默认分配一个随机端口，但你设置的0与默认值是相同的。</p><p><img src="http://btfak.com/images/api-design8.png" alt=""></p><p>大部分时候，你的API用户只是想使用你的默认值。</p><p>即使他们不想改变你的配置的任何内容，仍然不得不传入一些参数。</p><p>当你的用户读你的测试代码或者示例代码时，在想着怎样使用你的包，他们会看到这个魔幻的空字符串参数。</p><p>对我来说，这让我感觉很糟糕。</p><p>为什么你的API的用户需要传入一个空的值，只是简单的让你的函数满足声明需求？</p><p><img src="http://btfak.com/images/api-design9.png" alt=""></p><p>一个常见的解决办法是传入一个结构体指针，这让调用者可以传入nil，而不用考虑空值的问题。</p><p>在我看来，这个方案有前面的示例中的所有问题，甚至让问题更复杂了。</p><p>首先，我们仍然需要在第二个参数传入点什么，但目前，这个参数可以是nil了，而且大部分时候，对于默认的使用者，它就是nil。</p><p>使用指针的方式，包的作者和使用者都会担心的是，他们引用了同一份数据，随时有可能在运行中这份数据被修改而发生突变。</p><p>我想设计精良的API不应该要求用户传递这些额外的参数，只是为了应对一些罕见的情况。</p><p>我认为我们，Go程序员，应该努力确保不要求用户传递一个nil作为参数。</p><p>如果我们想要传递配置信息时，这应该是自解释的，尽量的有表达性。</p><p>现在，我们怀着这样的理念，我讨论一下我认为更好的解决方案。</p><p><img src="http://btfak.com/images/api-design10.png" alt=""></p><p>我们可以让API把不必须的参数作为一个变参。</p><p>不是传入nil，或者一些值为0的结构体，这种函数的设计发出了这样的信号：你不需要在config上传入任何参数。</p><p>在我看来这解决了两个问题。</p><p>首先，默认的调用方式变得简介命了。</p><p>其次，NewServer现在只接受config的值，不是指针，移除了nil和其他可能的参数，确保用户不会修改已经传入的参数。</p><p>我认为这个一个巨大的提升。</p><p>但我们深究一下，这仍然有问题。</p><p>明显对你的预期是提供最多一个config值，但这个参数是变参，实现的时候需要考虑用户传入多个参数的情况。</p><p>我们可以既能使用变参，同时也能提高我们的参数的表达性吗？</p><p>我认为这就是结局方案。</p><p><img src="http://btfak.com/images/api-design11.png" alt=""></p><p>在这里我想要说清楚，函数式参数的想法是来自于Rob Pike的这篇文章：<a href="http://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">Self referential functions and design</a> ，我鼓励每个人都去看看。</p><p>这种方式与上面的例子关键的不同在于，服务的定制化并不是通过传递参数实现的，而是通过函数来直接修改server的配置本身。</p><p>正如前面看到的，不传递变参让我们使用默认的方式。</p><p>当需要进行配置时，我们传递一个操作server的配置的函数。</p><p>上面的代码中，timeout这个函数是用于改变server的配置中的timeout字段。</p><p>在NewServer的实现内部，直接应用这些函数即可。</p><p>在上面的代码中，我们调用了一个 net.Listener，在server的示例中，我们使用了这个默认的listener。</p><p>然后，对于每个传入的option，我们都调用它，把我们的配置传入进去。</p><p>很明显，如果没有option传递进来，我们就使用的是默认的server.</p><p>使用这种方式，我们可以让API有这样的特性</p><ul><li>默认情况是实用的</li><li>高度可配置</li><li>配置可以不断增长</li><li>自解释的文档</li><li>对新的使用者很安全</li><li>不会要求传入一个nil的或者空值（只是为了让编译通过）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章是Dave Cheney在2014年发表的，我认为在go语言的接口设计上，这篇文章起到了指明灯的作用，包括Micro在内的框架，都使用了这种方式提供API。原文看这里&lt;/p&gt;
&lt;p&gt;正文开始：&lt;/p&gt;
&lt;p&gt;下面的内容是我的一次演示的文字版本，这是我在dotGo上演
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>可插拔式代码结构思考</title>
    <link href="http://lqczzz.github.io/2018/12/12/%E5%8F%AF%E6%8F%92%E6%8B%94%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%80%9D%E8%80%83/"/>
    <id>http://lqczzz.github.io/2018/12/12/可插拔式代码结构思考/</id>
    <published>2018-12-12T11:10:36.000Z</published>
    <updated>2018-12-23T17:04:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2>什么是可插拔式框架</h2><p>最早接触可插拔式的框架是python的flask，当时觉得这玩意老牛逼了，任何组件都能替换，你可以用jinja2/mako来做模版引擎，你可以选择SQLAlchemy或者其他orm框架来操作数据库。</p><p>思考了很久，pluggable的本质在于可替换。可替换在软件开发处处都可以体现，比如mysql驱动和mysql驱动实现，orm框架和数据库连接池，同样的orm框架，可以使用不同的连接池。而这种可替换在于抽象，golang标准库给我们提供了一套标准的sql操作接口，不同数据库只要实现这个接口。</p><p>这样想，pluggable也是离不开抽象的。抽空研究了一下micro的代码，发现，确实如此。</p><h2>可默认，可替换</h2><h3>1. 默认参数</h3><p><code>pluggable</code>,最直观的理解大概就是“可以替换，不替换也行”。在编码中，很多语言天生有一项能力和这个类似——默认参数：</p><pre><code># pythondef test(name=&quot;lqczzz&quot;):    print(name)test()  # &quot;lqczzz&quot;test(&quot;jack&quot;)  # &quot;jack&quot;</code></pre><p>这里，name这个变量是可以替换的，某种意义上也可以说是“pluggable”</p><h3>2. 可选参数 + 默认值</h3><p>默认参数很方便，<code>golang</code>没有默认参数,可以通过可选参数和默认值来实现</p><pre><code>const DefaultName = &quot;lqczzz&quot;func test(args ...string) {    name := DefaultName    if len(args) != 0 { name = args[0] }    fmt.Println(name)}// 不传参数test() // &quot;lqczzz&quot;// 传参数test(&quot;jack&quot;) // &quot;jack&quot;</code></pre><p>micro的可插拔式的实现本质上也是如此。</p><pre><code>// eg:type iBE interface {    FeatureImpl()}type beOption struct {    pm iPM}type qczzzl struct {    opts beOption}func (qc *qczzzl) FeatureImpl() {    qc.opts.pm.AddFeature()    fmt.Println(&quot;qczzzl will implement it!&quot;)}pm = &amp;defaultPM{}be = &amp;qczzzl{opts: beOption{pm: pm}}be.FeatureImpl()// output:// zhangiaolong add feature// qczzzl will implement it!// 换pmnewPm := &amp;pmLiyunlong{}be.opts.pm = newPm be.FeatureImpl()// output:// liyunlong add feature// qczzzl will implement it!</code></pre><h3>3. 接口</h3><h2>函数式参数</h2><h2>模块的抽象</h2><p>变化和不变</p><p>接口契约不变实现方式变化</p><p>struct封装依赖的变化（不变的契约依赖）封装通用数据（不变的数据依赖）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;什么是可插拔式框架&lt;/h2&gt;
&lt;p&gt;最早接触可插拔式的框架是python的flask，当时觉得这玩意老牛逼了，任何组件都能替换，你可以用jinja2/mako来做模版引擎，你可以选择SQLAlchemy或者其他orm框架来操作数据库。&lt;/p&gt;
&lt;p&gt;思考了很久，plugg
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[转]go服务监控指标(metric)上报open-falcon</title>
    <link href="http://lqczzz.github.io/2018/11/26/%E8%BD%AC-go%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87-metric-%E4%B8%8A%E6%8A%A5open-falcon/"/>
    <id>http://lqczzz.github.io/2018/11/26/转-go服务监控指标-metric-上报open-falcon/</id>
    <published>2018-11-26T05:20:30.000Z</published>
    <updated>2018-11-26T05:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://segmentfault.com/a/1190000014646203#articleHeader3" target="_blank" rel="noopener">出处</a></p></blockquote><h2>1. 概述</h2><p>指标统计是实现APM（Application performance management)的基础，通常通过一些指标的统计以及上报，我们可以了解程序的运行状况，及时发现程序的问题，提前预估系统瓶颈．指标(metric)目前的实现有metrics,这是java的实现，可以直接引入程序作为库使用．go语言的实现见go-metrics.另外，这里只是将指标在内存中进行处理及计算，如果我们想要展示，需要将数据抛出来，这里可以抛到日志里，也可以抛到时序数据库，最简单的做法就是直接抛到监控系统进行绘图或者报警．因此本文后面将讲解各指标的含义以及如何将计算好的数据抛到监控open-falcon</p><h2>2.指标统计方式</h2><h3>2.1 Meters</h3><p>用于计算一段时间内的计量，通常用于计算接口调用频率，如QPS(每秒的次数)，主要分为rateMean,Rate1/Rate5/Rate15等指标．</p><p>RateMean单位时间内发生的次数，如一分钟发送100次，则该值为100/60.</p><p>Rate1/Rate5/Rate151分钟/5分钟/15分钟内的滑动平均值(moving average),</p><h3>2.2 Gauges</h3><p>用于对瞬时值的测量，如我们可以过一段时间就对内存的使用量进行统计，并上报，那么所有的数据点集就是对应时间点的内存值，Gauges只有value指标．也就是上报的是什么就是什么．</p><h3>2.3 Counter</h3><p>计数类统计，可以进行加或减，也可以进行归零操作，所有的操作都是在旧值的基础上进行的．这里可以通过每天归零，然后新增注册用户时加1来统计每天的注册用户．</p><h3>2.4 Histograms</h3><p>主要用于对数据集中的值分布情况进行统计，典型的应用场景为接口耗时，接口每次调用都会产生耗时，记录每次调用耗时来对接口耗时情况进行分析显然不现实．因此将接口一段时间内的耗时看做数据集，并采集Count，Min, Max, Mean, Median, 75%, 95%, 99%等指标．以相对较小的资源消耗，来尽可能反应数据集的真实情况．</p><p><code>Count</code>距离上次清理后产生的样本数量．</p><p><code>Min</code>样本中的最小值</p><p><code>Max</code>样本中的最大值</p><p><code>Mean</code>所有样本的求得的平均值</p><p><code>Median</code>样本中的中间位置的值．</p><p><code>75%</code>样本中的%75位置的值．</p><p><code>95%</code>样本中的%95位置的值．</p><p><code>99%</code>样本中的%99位置的值．</p><h3>2.5 Timers</h3><p>对某个代码模块同时进行统计调用频率以及调用耗时统计．指标就是Histograms以及Meters两种统计方式的合集．</p><h2>3.使用方式</h2><p>更对详细用法见go-metric文档</p><h3>3.1 Counter</h3><pre><code>c := metrics.NewCounter()metrics.Register(&quot;foo&quot;, c)//进行加操作c.Inc(47)//进行减操作c.Dec(1)//获取出值c.Count()</code></pre><h3>3.2 Gauge</h3><pre><code>g := metrics.NewGauge()metrics.Register(&quot;bar&quot;, g)//更新瞬时值g.Update(47)//获取出瞬时值g.Value()</code></pre><h3>3.3 Meters</h3><pre><code>m := metrics.NewMeter()metrics.Register(&quot;quux&quot;, m)//写入数据集m.Mark(47)//获取数据集只读快照m := metric.Snapshot()//数据集大小m.Count()//1分钟滑动平均值m.Rate1()//5分钟滑动平均值m.Rate5()//15分钟滑动平均值m.Rate15()//平均值m.RateMean()3.4 Histogramsh := metrics.NewHistogram(s)metrics.Register(&quot;baz&quot;, h)//写入数据集h.Update(47)//获取数据集只读快照h := metric.Snapshot()//数据集大小h.Count()//最小值h.Min()//最大值h.Max()//平均值h.Mean()ps := h.Percentiles([]float64{0.5, 0.75, 0.95, 0.99})//中位数ps[0]//75%的数ps[1]//95%的数ps[2]//99%的数ps[3]3.5 Timert := metrics.NewTimer()metrics.Register(&quot;bang&quot;, t)t.Time(func() {    //do some thing})t.Update(47)//获取方式同meter以及Histograms</code></pre><h2>4. 指标上报到open-falcon</h2><h3>4.1 上报方式</h3><p>代码及使用方式见 go-metrics-falcon</p><p>实现数据上报open-falcon，只需要将所有数据取出，按open-falcon格式上报即可，这里有涉及到上报json的定义，具体如下．</p><pre><code>{    &quot;endpoint&quot;: &quot;$endpoint&quot;,    &quot;metric&quot;: &quot;$name&quot;,    &quot;value&quot;: 2.2,    &quot;step&quot;: 60,    &quot;counterType&quot;: &quot;GAUGE&quot;,    &quot;tags&quot;: &quot;project=$projectName,metricType=meter,valueType=ratemean&quot;,    &quot;timestamp&quot;: 1524724608}</code></pre><ul><li>endpoint: 这一个一般是主机hostname，用于标注是哪台机器．</li><li>metric: 指标名，由用户定义</li><li>value: 指标的值</li><li>step: 上报的时间周期</li><li>counterType: 上报的类型,这里open-falcon只支持GAUGE以及COUNTER,因此统一使用GAUGE.</li><li>tags: 标签，用于却别指标，包含指标类型，值类型，项目名三项．</li><li>timestamp: 指标上报的时间戳，单位秒．</li></ul><h3>4.2 效果</h3><p>如图，输入endpoint, 然后在counter部分输入项目名就可以过滤出该项目上报的所有指标．<img src="https://segmentfault.com/img/remote/1460000014646208?w=1832&amp;h=501" alt="">点击指标，进入查询该指标的大图．<img src="https://segmentfault.com/img/remote/1460000014646209" alt=""></p><p>同时我们可以对指标设置监控，具体见open-falcon文档．</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014646203#articleHeader3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;出处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux查看日志常用命令</title>
    <link href="http://lqczzz.github.io/2018/11/11/linux%E6%9F%A5%E7%9C%8B%E6%97%A5%E5%BF%97%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://lqczzz.github.io/2018/11/11/linux查看日志常用命令/</id>
    <published>2018-11-11T07:45:27.000Z</published>
    <updated>2018-11-20T06:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2>命令</h2><h3>必须掌握</h3><ol><li>cat</li><li>grep</li><li>awk</li><li>tail</li><li>head</li><li>wc (word count)</li><li>less</li><li>sort[todo]</li><li>uniq[todo]</li></ol><h3>不太常用但是有用</h3><ol><li>sed</li><li>tac</li><li>nl</li></ol><h2>详细</h2><p>更详细用法可以 <code>man command</code></p><h3>1. cat</h3><ol><li>功能：<ol><li>查看一个文本所有信息（经常和grep结合）</li><li>黏合文件</li></ol></li><li>用法：cat [-benstuv] [file ...]</li><li>常用参数:共7个参数，常用的是-n-n  带上行数</li><li>demo<ol><li>合并文件cat test1 test2 &gt; test3 (&gt; 表示覆盖写，创建的意思)cat test1 test2 &gt;&gt; test3 (&gt;&gt; 表示追加写)</li><li>带行数的查看文件cat -n filename</li></ol></li></ol><h3>2. grep</h3><ol><li><p>功能：正则匹配的查找文件内容</p></li><li><p>用法：grep[-abcdDEFGHhIiJLlmnOopqRSsUVvwxZ][-A num][-B num][-C[num]][-e pattern][-f file][--binary-files=value][--color[=when]][--colour[=when]][--context[=num]][--label][--line-buffered][--null][pattern][file ...]</p></li><li><p>常用参数:-a   --text   #不要忽略二进制的数据。<br>-A&lt;显示行数&gt;   --after-context=&lt;显示行数&gt;   #除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br>-b   --byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。<br>-B&lt;显示行数&gt;   --before-context=&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前的内容。<br>-c    --count   #计算符合样式的列数。<br>-C&lt;显示行数&gt;    --context=&lt;显示行数&gt;或-&lt;显示行数&gt;   #除了显示符合样式的那一行之外，并显示该行之前后的内容。<br>-d &lt;动作&gt;      --directories=&lt;动作&gt;   #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。<br>-e&lt;范本样式&gt;  --regexp=&lt;范本样式&gt;   #指定字符串做为查找文件内容的样式。<br>-E      --extended-regexp   #将样式为延伸的普通表示法来使用。<br>-F   --fixed-regexp   #将样式视为固定字符串的列表。<br>-G   --basic-regexp   #将样式视为普通的表示法来使用。<br>-h   --no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。<br>-H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。<br>-i    --ignore-case   #忽略字符大小写的差别。<br>-l    --file-with-matches   #列出文件内容符合指定的样式的文件名称。<br>-L   --files-without-match   #列出文件内容不符合指定的样式的文件名称。<br>-n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。<br>-q   --quiet或--silent   #不显示任何信息。<br>-r   --recursive   #此参数的效果和指定“-d recurse”参数相同。<br>-s   --no-messages   #不显示错误信息。<br>-v   --revert-match   #显示不包含匹配文本的所有行。<br>-V   --version   #显示版本信息。<br>-w   --word-regexp   #只显示全字符合的列。<br>-x    --line-regexp   #只显示全列符合的列。<br>-y   #此参数的效果和指定“-i”参数相同。</p></li><li><p>正则匹配规则</p></li></ol><p>grep的规则表达式:</p><pre><code>^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。    $  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。    .  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    *  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    .*   #一起用代表任意字符。   []   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    [^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    \(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。    \&lt;      #锚定单词的开始，如:'\&lt;grep'匹配包含以grep开头的单词的行。    \&gt;      #锚定单词的结束，如'grep\&gt;'匹配包含以grep结尾的单词的行。    x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    x\{m,\}  #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    x\{m,n\}  #重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   \w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   \W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   \b    #单词锁定符，如: '\bgrep\b'只匹配grep</code></pre><ol start="4"><li>demo<ol><li>查看进程 <code>ps -ef|grep svn</code></li><li>统计进程数 <code>ps -ef|grep svn -c</code></li><li>管道查看关键字的行 <code>cat test.txt | grep -F keyword</code></li><li>管道查看关键字的行并且打印行号<code>cat test.txt | grep -nf keyword</code></li><li>直接根据关键字查看行 <code>grep keyword filename</code></li><li>多文件 <code>grep keyword filename1 filename2</code></li><li>所有文件 <code>grep keyword *</code></li><li>查看以**开头的行 <code>cat test.txt |grep ^u</code></li><li>查看以**结尾的行 <code>cat test.txt |grep hat$</code></li><li>查看不以**开头的行 <code>cat test.txt |grep ^[^u]</code></li><li>查看有**或者**的行<code>cat test.txt |grep -E &quot;ed|at&quot;</code></li></ol></li></ol><h3>awk</h3><ol><li><p>功能：awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。特别适合一行文本特别长的时候进行显示处理</p></li><li><p>用法：awk '{pattern + action}' {filenames}其中action支持多种操作，强大又复杂</p></li><li><p>常用参数:-F：分割符</p></li><li><p>demo</p><ol><li>查看某一行的前面部分：<code>cat filename | awk -F '|' '{print $1, $2}'</code></li></ol></li></ol><h3>tail/head</h3><ol><li>功能：tail 显示文件末尾/开始的内容</li><li>用法：<ul><li>tail [-F | -f | -r] [-q] [-b number | -c number | -n number] [file ...]</li><li>head [-n count | -c bytes] [file ...]</li></ul></li><li>常用参数:-f：循环读取-n&lt;行数&gt;： 显示行数</li><li>demo<ol><li>监控日志：<code>tail -f filename</code></li><li>从第n行开始查看文件：<code>tail -n +100 filename</code> (必须有<code>+</code>)</li><li>查看前n行的内容：<code>head -n 20 filename</code></li><li>查看n-m行之间的内容：<code>cat -n info.log | tail -n +140 | head -n 2</code></li></ol></li></ol><h3>wc</h3><ol><li>功能：wc -- word, line, character, and byte count</li><li>用法：wc [-clmw] [file ...]</li><li>常用参数:-c 统计字节数。-l 统计行数。-m 统计字符数。这个标志不能与 -c 标志一起使用。-w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串</li><li>demo<ol><li>统计行数: <code>wc -l filename</code></li><li>统计当前目录下的文件数: <code>ls -l | wc -l</code></li></ol></li></ol><h3>less</h3><p>less 命令（分页查看文件内容）分页查看日志，但是中文有乱码<code>less error.log</code>直接定位到第100行<code>less +100g xx.log</code>定位到最后一行<code>less +GG xx.log</code>查找并高亮关键字<code>less fis.log.2018-05-20 | grep 2018052019004984219071028 -A 5 --color=auto</code>移动日志G ：到日志最后g ：到日志最前面j/↑ ：向前移动一行k/↓ ：向后移动一行pgup ：向上翻页pgdn ：向下翻页</p><h3>sed</h3><p>查看n-m行之间的内容： <code>sed -n '5,10p' filename</code></p><h3>tac</h3><p>和cat反着来的</p><h3>nl</h3><p>加强版 <code>cat -n</code>,使用参考 <code>man nl</code></p><h2>常用组合</h2><ol><li><p>实时监控日志：</p><pre><code> tail -f 20 filename</code></pre></li><li><p>显示一个文件的某几行</p><pre><code> 1. `cat -n  info.log | tail -n +140 | head -n 2` 2. `sed -n &quot;10,20p&quot; filename`</code></pre></li><li><p>统计行数：</p><pre><code> 1. wc -l filename</code></pre></li><li><p>现在有一万多条记录，其中包含重复的记录，每条记录占一行，问如何从这些记录中找到数量排名前10的记录:</p><pre><code> sort data | uniq -c | sort -k 1 -n -r | head 10</code></pre><blockquote><ol><li>sort data表示对data文件中的内容进行排序。sort命令是对于每一行的内容根据字典序（ASCII码）进行排序，这样可以保证重复的记录时相邻的。</li><li>sort data | uniq -c这里，通过管道（|）将左边部分的命令的输出作为右边部分的输入。uniq -c 表示合并相邻的重复记录，并统计重复数。因为uniq -c 只会合并相邻的记录，所以在使用该命令之前需要先排序。</li><li>sort data | uniq -c | sort -k 1 -n -r经过uniq -c 处理之后的数据格式形如&quot;2 data&quot;，第一个字段是数字，表示重复的记录数；第二个字段为记录的内容。我们将对此内容进行排序。sort -k 1表示对于每行的第一个字段进行排序，这里即指代表重复记录数的那个字段。因为sort命令的默认排序是按照ASCII，这就会导致按从大到小进行排序时，数值2会排在数值11的前面，所以需要使用-n 参数指定sort命令按照数值大小进行排序。-r 表示逆序，即按照从大到小的顺序进行排序。</li><li>sort data | uniq -c | sort -k 1 -n -r | head 10head 命令表示选取文本的前x行。通过head 10 就可以得到排序结果中前十行的内容</li></ol><p>来自<a href="http://eriol.iteye.com/blog/870641" target="_blank" rel="noopener">blog</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;命令&lt;/h2&gt;
&lt;h3&gt;必须掌握&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;cat&lt;/li&gt;
&lt;li&gt;grep&lt;/li&gt;
&lt;li&gt;awk&lt;/li&gt;
&lt;li&gt;tail&lt;/li&gt;
&lt;li&gt;head&lt;/li&gt;
&lt;li&gt;wc (word count)&lt;/li&gt;
&lt;li&gt;less&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>模版模式在golang的使用</title>
    <link href="http://lqczzz.github.io/2018/10/27/golang%E7%BB%84%E5%90%88%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>http://lqczzz.github.io/2018/10/27/golang组合和继承/</id>
    <published>2018-10-27T10:05:57.000Z</published>
    <updated>2018-10-27T11:12:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2>从需求说起</h2><p>还是timeline（微博／朋友圈etc）的业务场景。timeline业务从步骤上考虑，无非就是几个步骤：</p><ol><li>获取不同的数据队列（通常是meta信息)</li><li>根据一定的算法合并和截取数据</li><li>根据合并后的meta数据获取详细的信息（content信息)</li><li>返回</li></ol><p><em>如果第一步直接获取meta信息和content信息，则信息太大，tcp耗时和内存消耗也很多</em></p><p>另外，timeline可能会分成很多类型：</p><ol><li>用户未登录看到的</li><li>用户登录看到的</li><li>推荐列表</li><li>etc</li></ol><p>这种场景最适合用模版模式实现了在java里面：</p><pre><code>public asbtract class BaseTimeline {    public void Do() {        this.doRetrieve()        this.doMerge()        this.doGetContent()    }    abstract void doRetrieve()    abstract void doMerge()    abstract void doGetContent()}class LoginedTimeline extends BaseTimeline {    public void doRetrieve() {}    public void doMerge() {}    public void doGetContent() {}}class UnLoginedTimeline extends BaseTimeline {    public void doRetrieve() {}    public void doMerge() {}    public void doGetContent() {}}// 场景类public class Server {    private BaseTimeline timeline     public static void main([]string args) {        if args[0] == &quot;&quot; {            timeline = new LoginedTimeline()        } else {            timeline = new UnLoginedTimeline()        }        timeline.Do()    }}</code></pre><p>通过模版模式可以很方便的实现对timeline的扩展，新增不同的展示方式直接新增timeline类。在java servlet编程和图形界面开发(android view, html5 vue .etc)中是很常见的设计模式</p><p>可是golang的组合的方式没办法支持抽象方法</p><pre><code>type ITimeline interface {    doRetrieve()   // 获取不同的队列    doMerge()      // 合并    doGetContent() // 获取详情    Do()}type BaseTimeline struct{}func (bt *BaseTimeline) doRetrieve()   { fmt.Println(&quot;base retrieve&quot;) }func (bt *BaseTimeline) doMerge()      { fmt.Println(&quot;base merge&quot;) }func (bt *BaseTimeline) doGetContent() { fmt.Println(&quot;base content&quot;) }func (bt *BaseTimeline) Do() {    bt.doRetrieve()    bt.doMerge()    bt.doGetContent()}type LoginedTimeline struct {    BaseTimeline}func (bt *LoginedTimeline) doRetrieve()   { fmt.Println(&quot;LoginedTimeline retrieve&quot;) }func (bt *LoginedTimeline) doMerge()      { fmt.Println(&quot;LoginedTimeline merge&quot;) }func (bt *LoginedTimeline) doGetContent() { fmt.Println(&quot;LoginedTimeline content&quot;) }type UnLoginedTimeline struct {    BaseTimeline}func (bt *UnLoginedTimeline) doRetrieve()   { fmt.Println(&quot;UnLoginedTimeline retrieve&quot;) }func (bt *UnLoginedTimeline) doMerge()      { fmt.Println(&quot;UnLoginedTimeline merge&quot;) }func (bt *UnLoginedTimeline) doGetContent() { fmt.Println(&quot;UnLoginedTimeline content&quot;) }// 使用type GetTimelineRequest struct {    UserID uint64}func server(request, response interface{}) {    // GetTimelineRequest is a struct    var timeline ITimeline    switch UserID := request.(*GetTimelineRequest).UserID; {    case UserID != uint64(0):        timeline = &amp;LoginedTimeline{}    default:        timeline = &amp;UnLoginedTimeline{}    }    timeline.Do()}func main() {    req := &amp;GetTimelineRequest{}    server(req, nil)}// 输出：// base retrieve// base merge// base content</code></pre><p>原因是因为组合方式不支持方法覆盖可以把Do单独出来：</p><pre><code>type ITimeline interface {    doRetrieve()   // 获取不同的队列    doMerge()      // 合并    doGetContent() // 获取详情}type BaseTimeline struct{}func (bt *BaseTimeline) doRetrieve()   { fmt.Println(&quot;base retrieve&quot;) }func (bt *BaseTimeline) doMerge()      { fmt.Println(&quot;base merge&quot;) }func (bt *BaseTimeline) doGetContent() { fmt.Println(&quot;base content&quot;) }// !!! 这里Do不再是具有接收者的方法了，调用方式也会不一样func Do(bt ITimeline) {    bt.doRetrieve()    bt.doMerge()    bt.doGetContent()}type LoginedTimeline struct {    BaseTimeline}func (bt *LoginedTimeline) doRetrieve()   { fmt.Println(&quot;LoginedTimeline retrieve&quot;) }func (bt *LoginedTimeline) doMerge()      { fmt.Println(&quot;LoginedTimeline merge&quot;) }func (bt *LoginedTimeline) doGetContent() { fmt.Println(&quot;LoginedTimeline content&quot;) }type UnLoginedTimeline struct {    BaseTimeline}func (bt *UnLoginedTimeline) doRetrieve()   { fmt.Println(&quot;UnLoginedTimeline retrieve&quot;) }func (bt *UnLoginedTimeline) doMerge()      { fmt.Println(&quot;UnLoginedTimeline merge&quot;) }func (bt *UnLoginedTimeline) doGetContent() { fmt.Println(&quot;UnLoginedTimeline content&quot;) }// 使用type GetTimelineRequest struct {    UserID uint64}func server(request, response interface{}) {    // GetTimelineRequest is a struct    var timeline ITimeline    switch UserID := request.(*GetTimelineRequest).UserID; {    case UserID != uint64(0):        timeline = &amp;LoginedTimeline{}    default:        timeline = &amp;UnLoginedTimeline{}    }    // 这里的调用方式也就变化了    Do(timeline)}func main() {    req := &amp;GetTimelineRequest{}    server(req, nil)}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;从需求说起&lt;/h2&gt;
&lt;p&gt;还是timeline（微博／朋友圈etc）的业务场景。
timeline业务从步骤上考虑，无非就是几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取不同的数据队列（通常是meta信息)&lt;/li&gt;
&lt;li&gt;根据一定的算法合并和截取数据&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="golang" scheme="http://lqczzz.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>break 和 continue</title>
    <link href="http://lqczzz.github.io/2018/10/26/break-in-golang/"/>
    <id>http://lqczzz.github.io/2018/10/26/break-in-golang/</id>
    <published>2018-10-26T10:49:42.000Z</published>
    <updated>2018-10-26T13:40:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang的break和continue挺好用的，和别的语言不太一样</p><h1>break</h1><p>golang的<code>break</code>关键字<code>for</code>,<code>switch</code>,<code>select</code>会跳出三个关键字的包裹</p><blockquote><p><a href="https://golang.org/ref/spec#Break_statements" target="_blank" rel="noopener">A &quot;break&quot; statement terminates execution of the innermost &quot;for&quot;, &quot;switch&quot;, or &quot;select&quot; statement within the same function. —— 《The Go Programming Language Specification》</a></p></blockquote><p>下面一段代码</p><pre><code>for i := 0; i &lt; 6; i++ {switch i {case 2:breakdefault:fmt.Println(i)}}// go run main.go：// 0// 1// 3// 4// 5</code></pre><p>如果想跳出更上一层的<code>for</code>关键字，需要指定<code>label</code></p><pre><code>forLoop:    for i := 0; i &lt; 6; i++ {        switch i {        case 2:            break forLoop        default:            fmt.Println(i)        }    }// go run main.go:// 0// 1</code></pre><h1>continue</h1><p><code>continue</code>也可以指定label</p><pre><code>forLoop:    for i := 0; i &lt; 6; i++ {        switch i {        case 2:            continue forLoop        default:            fmt.Println(i)        }    }// go run main.go// 0// 1// 3// 4// 5</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;golang的break和continue挺好用的，和别的语言不太一样&lt;/p&gt;
&lt;h1&gt;break&lt;/h1&gt;
&lt;p&gt;golang的&lt;code&gt;break&lt;/code&gt;关键字&lt;code&gt;for&lt;/code&gt;,&lt;code&gt;switch&lt;/code&gt;,&lt;code&gt;select&lt;
      
    
    </summary>
    
    
      <category term="golang思考" scheme="http://lqczzz.github.io/tags/golang%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
