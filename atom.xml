<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lqczzz.github.io/"/>
  <updated>2018-10-21T13:03:52.000Z</updated>
  <id>http://lqczzz.github.io/</id>
  
  <author>
    <name>lqczzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>unix网络编程笔记（1）</title>
    <link href="http://lqczzz.github.io/2018/10/21/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://lqczzz.github.io/2018/10/21/unix网络编程笔记（1）/</id>
    <published>2018-10-21T06:00:26.000Z</published>
    <updated>2018-10-21T13:03:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h2><p>假设你对OSI七层模型有所了解</p><h2 id="chapter0-简介"><a href="#chapter0-简介" class="headerlink" title="chapter0:简介"></a>chapter0:简介</h2><h3 id="从现代交换技术说起"><a href="#从现代交换技术说起" class="headerlink" title="从现代交换技术说起"></a>从现代交换技术说起</h3><p>《现代交换技术》是通信专业的必修课，嗯嗯，好歹我也是通信专业的学生，就先把知识脉络拓展一下～</p><p>现代交换技术的分类：</p><ol><li>电路交换</li><li>分组交换</li></ol><p>计算机网络的协议用的就是分组交换技术，我们发送的信息会像快递包裹一样一个个的传送到接收方。而电路交换很简单，就是每个通信实体都连接到交换机上，而交换机使用交换的方法，让实体之间可以很方便地通信，现在最广泛的应用就是电话网络了。<br>从打电话也可以看出来，电路交换一定是：</p><ol><li>面向连接；(分组交换则不一定，如udp协议)</li><li>同步时分复用；</li><li>信息传送无差错控制；</li></ol><h3 id="chapter1-分组交换协议"><a href="#chapter1-分组交换协议" class="headerlink" title="chapter1:分组交换协议"></a>chapter1:分组交换协议</h3><p><img src="/images/net/分组交换协议.png" alt="分组交换协议"></p><ol><li>PDU: 协议数据单元，即对等实体(处于同一层)之间的交换单元信息</li><li>SDU: 下一层承载上一层数据的单元，比如tcp层传输的tcp报文(报文头+报文体)数据在tcp层就是一个PDU，传给ip层之后，ip层认为它是SDU（ip层在tcp报文之外加入ip报文头，类似俄罗斯套娃）</li></ol><p>不同协议之间的不同完全取决于协议头（废话～）</p><h3 id="tcp／ip简介"><a href="#tcp／ip简介" class="headerlink" title="tcp／ip简介"></a>tcp／ip简介</h3><ol><li>一般认为web服务器程序是长时间运行的程序，即所谓的守护程序</li><li>用户进程定义应用协议，tcp和ip协议的转换和包装在内核协议栈中，由操作系统提供支持<br><img src="/images/net/1.1.png" alt=""></li><li><p>tcp是没有记录边界的字节流协议</p><ul><li>tcp应用进程之间是没有长度限制的字节流，udp进程交换的数据长度不能超过udp发送缓冲区大小的单个记录(record)</li><li>tcp协议：应用程序一次次输出操作写到socket的数据经过顺序分割，得到分节(segment)，<em>数据量太大的时候，我们无法确保一次read到所有的数据，所以必须要把read编写在某个循环中</em></li><li>tcp没有边界,所以tcp服务需要自己实现，提供一个表示长度的协议头</li></ul></li><li>ip报文的SDU最大是65535，所以tcp一次发送的报文大小不会超过64k<br> 对于平常实用的<code>conn.Write([]byte)</code>，我们是不用考虑这些，操作系统会对这类阻塞写操作进行自动分片并且不用考虑缓冲区写满的情况</li><li>套接字编程是应用层进入传输层的接口<ul><li>这样设计由两个理由：<ol><li>应用层对通信细节很少关心，而底下四层对应用协议不关心，只关心如何通信</li><li>应用层常构成用户进程，地下四层作为操作系统和内核的机制，存在与内核态</li></ol></li><li>socket可以绕过tcp和udp直接实用ipv4/ipv6，这种socket称为原始套接字(raw socket),很少用到，在整本书里面第28章介绍了它的两个用途：<ol><li>ping</li><li>traceroute<br>因此不打算深入了解了</li></ol></li></ul></li></ol><p><img src="/images/net/osi和网际协议的对应关系.png" alt="osi和网际协议的对应关系"></p><ol><li><code>netstat</code>和<code>ifconfig</code>可以很方便的查看网络的细节</li></ol><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h5><p>这里记录一个工作中遇到的bug：</p><pre><code>// 没有for循环读取数据func request(conn net.Conn, buffer bytes.Buffer, command []byte) error {    // 读协议头，得到body的长度    recvBuf := make([]byte, 4)    resHead := binary.LittleEndian.Uint32(recvBuf)    // 指定读取数据的大小，读取数据，bug:读取不完整    var resBody bytes.Buffer    recvBuf = make([]byte, resHead)    length, err := conn.Read(recvBuf)    if err != nil {        return err    }    return nil}</code></pre><p>bug分析：</p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ol><li>原因1:</li></ol><p><img src="/images/net/bug_coreserver.png" alt="bug"><br>socket上的read和write(操作系统的系统调用)不同于通常的文件读写，可能的到的字节数比预期的要少，原因在于内核缓冲区可能数据不够(read)或者缓冲区已经满了(non block write),上面的主要问题是read的时候缓冲区的数据不够，在项目中，由于网络原因，当我们</p><pre><code>var recvData = make([]byte, Size)conn.Read(recvData)</code></pre><p>这样获取数据，由于网络不稳定，可能缓冲区的数据足够，可能不够，所以出现了调用20次成功一次的情况<br>既然如此,为什么go实现<code>conn.Read()</code>为什么不帮我们阻塞去等待数据的到来呢</p><p>很遗憾<code>Read</code>没有这样的能力，go也没有提供类似c的<code>Readn</code>这样的接口</p><blockquote><p>If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.<br>来自 go io包Read接口的注释</p></blockquote><ol><li><p>原因2:</p><p> 不知道服务器端发送的逻辑(也不应该依赖它)，可能是</p><pre><code>for {    conn.Write() // 手动分片}</code></pre><p> 也可能是：</p><pre><code>conn.Write([]整个数据)</code></pre></li></ol><h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>套一层for循环</p><pre><code>// 修改成for循环读取数据，bug解决func request(conn net.Conn, buffer bytes.Buffer, command []byte) error {    // 读协议头，得到body的长度    recvBuf := make([]byte, 4)    resHead := binary.LittleEndian.Uint32(recvBuf)    // 指定读取数据的大小，读取数据，bug:读取不完整    var resBody bytes.Buffer    recvBuf = make([]byte, resHead)    for resBody.Len() &lt; int(resHead) {        length, err := conn.Read(recvBuf)        if err != nil {            return err        }        resBody.Write(recvBuf[:length])    }    return nil  }</code></pre><h2 id="chapter2-传输层：tcp-udp-sctp"><a href="#chapter2-传输层：tcp-udp-sctp" class="headerlink" title="chapter2:传输层：tcp/udp/sctp"></a>chapter2:传输层：tcp/udp/sctp</h2><p>主要讲了UDP／TCP／SCTP三种协议，SCTP日常用的少，以后再了解，重点讲了TCP编程，部分笔记来自第三章(方便总结)</p><h3 id="TCP-UDP协议族"><a href="#TCP-UDP协议族" class="headerlink" title="TCP/UDP协议族"></a>TCP/UDP协议族</h3><p><img src="/images/net/2.1总图.png" alt="总图"></p><ol><li>ipv4/ipv6对上层协议提供了分组递送的能力，不具有可靠性(丢包可能)</li><li>tcp是面向连接的流式套接字(stream socket)，关心确认／超时／重传的细节<ul><li>需要三次握手建立连接</li><li>源端数据发送需要对端确认，一段时间内(超时时间:RTT)收不到确认应答则重传，多次重传失败则终止传输<ul><li>RTT(round-trip time)一次客户端和服务器端往返时间</li></ul></li><li>流量控制：接收方可以告诉发送方下一次我能接受的数据量，防止接收方缓冲区溢出</li><li>tcp是全双工的</li></ul></li><li>udp是一种无连接的数据包报套接字(datagram socket)：<ul><li>不保证是否到达</li><li>不保证到达顺序</li><li>没有自动重传</li><li>没有超时概念</li><li>每个数据包都都有报文头标示长度等</li></ul></li></ol><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/images/net/基本的tcp_socket函数.png" alt="基本socket函数for tcp"></p><p>上图来自第五章，展示了基本的一个tcp客户端和服务端的socket系统调用函数的关系，具体每个系统调用的作用在下面总结。这里关心的是三次握手触发的时机:<em>服务端调用了accept，客户端调用connect主动打开</em></p><p><img src="/images/net/tcp三次握手.png" alt="三次握手"></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/images/net/tcp四次挥手.png" alt="四次挥手"></p><ol><li>主动关闭方(客户端)发送fin分节，意思是我该说的说完了，服务器收到立马回复说我收到了,然后这个分节放到服务端的缓冲区的末尾，等待应用程序处理</li><li>应用程序处理完了，服务端也需要发一个fin告诉客户端我也完事了</li><li>在服务端发送这两个分节的过程中，服务端仍然可以向客户端发送数据</li><li>缓冲队列没有数据，服务端也不需要发送数据的时候，服务端会合并发送<code>ack m+1</code>和<code>fin n</code>分节，这时候就是三次挥手了。</li><li>主动关闭方(客户端)响应了服务端的fin分节之后，会再等一段时间，进入<code>time_wait</code>状态，</li></ol><h2 id="chapter3-套接字编程简介"><a href="#chapter3-套接字编程简介" class="headerlink" title="chapter3:套接字编程简介"></a>chapter3:套接字编程简介</h2><h2 id="chapter4-基本tcp套接字编程"><a href="#chapter4-基本tcp套接字编程" class="headerlink" title="chapter4:基本tcp套接字编程"></a>chapter4:基本tcp套接字编程</h2><h2 id="chapter5-tcp客户／服务程序示例"><a href="#chapter5-tcp客户／服务程序示例" class="headerlink" title="chapter5:tcp客户／服务程序示例"></a>chapter5:tcp客户／服务程序示例</h2><h2 id="chapter30-客户／服务器程序设计范式"><a href="#chapter30-客户／服务器程序设计范式" class="headerlink" title="chapter30:客户／服务器程序设计范式"></a>chapter30:客户／服务器程序设计范式</h2><blockquote><p>《unix网络编程卷一》<br>《图解tcp/ip》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;阅读前提&quot;&gt;&lt;a href=&quot;#阅读前提&quot; class=&quot;headerlink&quot; title=&quot;阅读前提&quot;&gt;&lt;/a&gt;阅读前提&lt;/h2&gt;&lt;p&gt;假设你对OSI七层模型有所了解&lt;/p&gt;
&lt;h2 id=&quot;chapter0-简介&quot;&gt;&lt;a href=&quot;#chapter0-简介
      
    
    </summary>
    
    
      <category term="tcp/ip" scheme="http://lqczzz.github.io/tags/tcp-ip/"/>
    
  </entry>
  
  <entry>
    <title>优秀的博文记录</title>
    <link href="http://lqczzz.github.io/2018/10/18/%E4%BC%98%E7%A7%80%E7%9A%84%E5%8D%9A%E6%96%87%E8%AE%B0%E5%BD%95/"/>
    <id>http://lqczzz.github.io/2018/10/18/优秀的博文记录/</id>
    <published>2018-10-18T07:46:41.000Z</published>
    <updated>2018-10-18T07:47:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="golang优化"><a href="#golang优化" class="headerlink" title="golang优化"></a>golang优化</h2><p><a href="http://blog.cyeam.com/golang/2016/08/18/apatternforoptimizinggo" target="_blank" rel="noopener">优化Go的模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;golang优化&quot;&gt;&lt;a href=&quot;#golang优化&quot; class=&quot;headerlink&quot; title=&quot;golang优化&quot;&gt;&lt;/a&gt;golang优化&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://blog.cyeam.com/golang/2016/08/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>pprof性能监控和gc调优</title>
    <link href="http://lqczzz.github.io/2018/10/18/pprof%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8Cgc%E8%B0%83%E4%BC%98/"/>
    <id>http://lqczzz.github.io/2018/10/18/pprof性能监控和gc调优/</id>
    <published>2018-10-18T07:15:41.000Z</published>
    <updated>2018-10-18T07:40:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考<br><a href="https://golang.org/doc/diagnostics.html" target="_blank" rel="noopener">godoc-Diagnostics</a><br><a href="https://studygolang.com/articles/5527" target="_blank" rel="noopener">Golang使用pprof监控性能及GC调优</a><br><a href="https://blog.csdn.net/moxiaomomo/article/details/77096814" target="_blank" rel="noopener">[golang]pprof性能分析工具</a><br><a href=""></a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;https://golang.org/doc/diagnostics.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;godoc-Diagnostics&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;htt
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://lqczzz.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>sync.Pool笔记</title>
    <link href="http://lqczzz.github.io/2018/10/18/sync-Pool%E7%AC%94%E8%AE%B0/"/>
    <id>http://lqczzz.github.io/2018/10/18/sync-Pool笔记/</id>
    <published>2018-10-18T03:04:01.000Z</published>
    <updated>2018-10-18T07:24:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考<br><a href="https://studygolang.com/articles/3506" target="_blank" rel="noopener">1. o语言的官方包sync.Pool的实现原理和适用场景</a><br><a href="https://github.com/funny/slab/blob/master/sync_pool.go" target="_blank" rel="noopener">2. github-slab</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;https://studygolang.com/articles/3506&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1. o语言的官方包sync.Pool的实现原理和适用场景&lt;/a&gt;&lt;br&gt;&lt;a
      
    
    </summary>
    
    
      <category term="timeline重构任重道远" scheme="http://lqczzz.github.io/tags/timeline%E9%87%8D%E6%9E%84%E4%BB%BB%E9%87%8D%E9%81%93%E8%BF%9C/"/>
    
  </entry>
  
  <entry>
    <title>从golang的fmt包入门手动内存管理</title>
    <link href="http://lqczzz.github.io/2018/10/17/golang%E7%9A%84fmt%E5%8C%85%E5%85%A5%E9%97%A8%E6%89%8B%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://lqczzz.github.io/2018/10/17/golang的fmt包入门手动内存管理/</id>
    <published>2018-10-17T14:01:43.000Z</published>
    <updated>2018-10-17T15:05:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矫情的话"><a href="#矫情的话" class="headerlink" title="矫情的话"></a>矫情的话</h2><p>在做feed流开发的时候，我负责timeline的业务开发，刚开始设计的时候我以为也就是个业务代码开发，能有啥难度。结果开发完了之后，被leader疯狂吐槽。代码组织不好，这些都能通过对业务的深入理解，去重新设计，但是说到一个内存管理的问题，我是完全没想到的，以前没有接触过高并发场景，不知道在高并发场景下，依赖语言自身的gc会导致内存的频繁申请和回收。</p><p>痛定几周之后决定思痛，要参考学习优秀的代码<br>于是我想，哪里会有优秀的涉及到内存管理的代码呢！</p><p>官方库！！</p><p>然后想，timeline涉及网络io，io才会有大量的内存分配和回收的场景！！</p><p>直接看net包？太尼玛复杂了<br>ok，看fmt包</p><h2 id="fmt包源码摘要和笔记"><a href="#fmt包源码摘要和笔记" class="headerlink" title="fmt包源码摘要和笔记"></a>fmt包源码摘要和笔记</h2><blockquote><p>来自fmt/print.go</p></blockquote><pre><code>// Fprintf根据w的不同，调用w的write方法，很容易做到打印日志到不同地方func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {    p := newPrinter()    p.doPrintf(format, a)    n, err = w.Write(p.buf)    p.free()    return}// Printf调用了Fprintf，打印的地方是os.Stdoutfunc Printf(format string, a ...interface{}) (n int, err error) {    return Fprintf(os.Stdout, format, a...)}func Sprintf(format string, a ...interface{}) string {    p := newPrinter()    p.doPrintf(format, a)    s := string(p.buf)    p.free()    return s}</code></pre><p>这里至少有三点可以学:</p><ol><li>包本身就是模块化的一种方式，对外提供的函数不一定非得属于某个对象</li><li>接口作为参数的好处：封装变化<br> 这里，变化指的是[]byte的去向，比如os.Stdout</li><li><code>p := newPrinter()</code>这里采用了临时对象池来实现内存的管理</li></ol><p>看下去：</p><pre><code>// pp is used to store a printer&apos;s state and is reused with sync.Pool to avoid allocations.type pp struct {    buf buffer    // 省略}var ppFree = sync.Pool{    New: func() interface{} { return new(pp) },}// newPrinter allocates a new pp struct or grabs a cached one.func newPrinter() *pp {    p := ppFree.Get().(*pp)    p.panicking = false    p.erroring = false    p.fmt.init(&amp;p.buf)    return p}// free saves used pp structs in ppFree; avoids an allocation per invocation.func (p *pp) free() {    p.buf = p.buf[:0]   // 清空slice    p.arg = nil     p.value = reflect.Value{}    ppFree.Put(p)   // 放回对象池里}</code></pre><p>一个sync.Pool对象就是一组临时对象的集合。Pool是协程安全的。<br>Pool用于存储那些被分配了但是没有被使用，而未来可能会使用的值，以减小垃圾回收的压力。</p><p>fmt包总是需要使用一些[]byte之类的对象，golang建立了一个临时对象池，存放着这些对象，如果需要使用一个[]byte，就去Pool里面拿，如果拿不到就分配一份。<br>这比起不停生成新的[]byte，用完了再等待gc回收来要高效得多</p><h2 id="sync-Pool测试"><a href="#sync-Pool测试" class="headerlink" title="sync.Pool测试"></a>sync.Pool测试</h2><pre><code>// 一个[]byte的对象池，每个对象为一个[]bytevar bytePool = sync.Pool{    New: func() interface{} {        b := make([]byte, 1024)        return &amp;b    },}func main() {    a := time.Now().Unix()    // 不使用对象池    for i := 0; i &lt; 1000000000; i++ {        obj := make([]byte, 1024)        _ = obj    }    b := time.Now().Unix()    // 使用对象池    for i := 0; i &lt; 1000000000; i++ {        obj := bytePool.Get().(*[]byte)        _ = obj        bytePool.Put(obj)    }    c := time.Now().Unix()    fmt.Println(&quot;without pool &quot;, b-a, &quot;s&quot;)    fmt.Println(&quot;with    pool &quot;, c-b, &quot;s&quot;)}</code></pre><blockquote><p>来自：<a href="https://www.jianshu.com/p/2bd41a8f2254" target="_blank" rel="noopener">go的临时对象池–sync.Pool</a></p></blockquote><p>测试效果：</p><pre><code>// 数据量更大更明显without pool  21 swith    pool  16 s</code></pre><p>the end…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;矫情的话&quot;&gt;&lt;a href=&quot;#矫情的话&quot; class=&quot;headerlink&quot; title=&quot;矫情的话&quot;&gt;&lt;/a&gt;矫情的话&lt;/h2&gt;&lt;p&gt;在做feed流开发的时候，我负责timeline的业务开发，刚开始设计的时候我以为也就是个业务代码开发，能有啥难度。结果开发
      
    
    </summary>
    
    
      <category term="timeline重构任重道远" scheme="http://lqczzz.github.io/tags/timeline%E9%87%8D%E6%9E%84%E4%BB%BB%E9%87%8D%E9%81%93%E8%BF%9C/"/>
    
  </entry>
  
  <entry>
    <title>一次goroutine内存泄漏问题定位</title>
    <link href="http://lqczzz.github.io/2018/10/16/%E4%B8%80%E6%AC%A1goroutine%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    <id>http://lqczzz.github.io/2018/10/16/一次goroutine内存泄漏问题定位/</id>
    <published>2018-10-16T05:38:08.000Z</published>
    <updated>2018-10-21T05:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><p>问题：</p><p><img src="/images/goroutine-leak.png" alt="goroutine-leak"></p><p>Dump goroutines:</p><pre><code>ps aux | grep &apos;content_svr&apos; #43kill -USR2 43</code></pre><p>比较两小时间的Diff：<br>两小时前:</p><pre><code>$ grep &apos;cron/hashtag_suggestion&apos; /proc/43/fd/11$ grep &apos;producer&apos; /proc/43/fd153</code></pre><p>两小时后:</p><pre><code>$ grep &apos;cron/hashtag_suggestion&apos; /proc/43/fd/141$ grep &apos;producer&apos; /proc/43/fd1221</code></pre><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><pre><code>// 简化了业务逻辑type Cron struct{    ch1 chan []int    ch2 chan []int}func (cron *Cron)start() {    timer := time.NewTicker(cron.taskDuration)    for {        select {        case &lt;-timer.C:            cron.doCron()        }    }}func (cron *Cron)doCron() {    cron.step1()    cron.step2()    cron.step3()}func (cron *Cron)step1() {    go func(){        cron.ch1 &lt;- []int{100}        // 注意这里没有关闭ch1，导致下面的goroutine一直没有关闭    }()}func (cron *Cron)step2() {    go func(){        for item := range cron.ch1 {            _ = item            cron.ch2 &lt;- []int{200}            // 注意这里没有关闭ch2，导致下面的goroutine一直没有关闭        }    }()}func (cron *Cron)step3() {    go func(){        for item := range cron.ch2 {            _ = item        }    }()}</code></pre><h2 id="纠正"><a href="#纠正" class="headerlink" title="纠正"></a>纠正</h2><pre><code>// 1. 每次创建goroutine时候创建channel// 2. 每次使用完channel，close channel，退出goroutinetype Cron struct{    ch1 chan []int    ch2 chan []int}const (    concurrency = 100)func (cron *Cron)start() {    timer := time.NewTicker(cron.taskDuration)    for {        select {        case &lt;-timer.C:            cron.doCron()        }    }}func (cron *Cron)doCron() {    cron.ch1 = make(chan []int, concurrency) // fixed    cron.ch2 = make(chan []int, concurrency) // fixed    cron.step1()    cron.step2()    cron.step3()}func (cron *Cron)step1() {    go func(){        cron.ch1 &lt;- []int{100}        close(ch1) // fixed    }()}func (cron *Cron)step2() {    go func(){        for item := range cron.ch1 {            _ = item            cron.ch2 &lt;- []int{200}            close(ch2) // fixed        }    }()}func (cron *Cron)step3() {    go func(){        for item := range cron.ch2 {            _ = item        }    }()}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定位过程&quot;&gt;&lt;a href=&quot;#定位过程&quot; class=&quot;headerlink&quot; title=&quot;定位过程&quot;&gt;&lt;/a&gt;定位过程&lt;/h2&gt;&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/goroutine-leak.png&quot; alt=&quot;goroutin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>知识管理</title>
    <link href="http://lqczzz.github.io/2018/10/14/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    <id>http://lqczzz.github.io/2018/10/14/知识管理/</id>
    <published>2018-10-14T03:06:31.000Z</published>
    <updated>2018-10-14T11:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么这样分类"><a href="#为什么这样分类" class="headerlink" title="为什么这样分类"></a>为什么这样分类</h2><p>笔记用于我对知识的掌握，工作快两年了我才发现了知识的几个特点：</p><ol><li><p>很多知识机靠记忆是没办法持久化存储的</p><ul><li>比如前端vue框架，我用了大半年了，发现才转后台3个月，vue的很多东西就忘的差不多了</li><li>比如spring相关的框架，从大学开始使用到现在，断断续续，每次重新使用都得重新学习一遍，虽然每次学习的时间会越来越缩短。</li><li>比如开发工具，使用的编辑器的快捷键的使用等，都是很容易遗忘但是有没必要刻意去记住的</li></ul></li><li><p>很多知识是细枝末节的</p><ul><li><p>比如某种框架，框架其实是一种架构良好的工具，提供了某种不变的东西，让你快速实现某种变化，来适应不同的业务场景。比如spring系的的框架，模版设计模式就很常用，你只要继承某种基类，然后实现特定的抽象函数（钩子函数），就能完成一个不同的功能，而前端框架vue的组件化就是最明显的模板模式的应用。框架是一种工具，工具的实现和接口都是细枝末节的，就算完全忘记了，只要拿上一个上午的时间甚者更短，就能再次掌握起来了。</p></li><li><p>在华为曾做过一个项目，后台开始是用node实现的，领导觉得node不安全，于是让我们用java重构，并且做好服务化，我们把微服务当作银弹，结果重构之后更加难部署了，项目的规模也没有达到必须使用服务化的必要。这就是锤子理论，拿起锤子，觉得什么都是钉子。</p></li></ul></li></ol><ol><li><p>很多知识是可以进行类比的</p><ul><li>比如web框架，不管是node的koa，python的flask还是golang的gin，都是有很多通用的概念，常用的套路，相同的业务场景和解决方案，举一反三对掌握新的工具是很有用的</li></ul></li><li><p>很多知识是可以快速掌握和应用的</p></li></ol><h2 id="分类的策略"><a href="#分类的策略" class="headerlink" title="分类的策略"></a>分类的策略</h2><ol><li>入门类：对概念和基本流程有一个基本的认识</li><li>笔记类：<ul><li>常用的用法的记录</li></ul></li><li>原理类：<ul><li>对入门类有更详细的认识</li></ul></li><li>实战类：<ul><li>具体场景下的使用</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么这样分类&quot;&gt;&lt;a href=&quot;#为什么这样分类&quot; class=&quot;headerlink&quot; title=&quot;为什么这样分类&quot;&gt;&lt;/a&gt;为什么这样分类&lt;/h2&gt;&lt;p&gt;笔记用于我对知识的掌握，工作快两年了我才发现了知识的几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;很多
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>elasticSearch学习笔记</title>
    <link href="http://lqczzz.github.io/2018/10/13/elasticSearch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://lqczzz.github.io/2018/10/13/elasticSearch学习笔记/</id>
    <published>2018-10-13T14:29:32.000Z</published>
    <updated>2018-10-17T05:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="elasticSearch入门"><a href="#elasticSearch入门" class="headerlink" title="elasticSearch入门"></a>elasticSearch入门</h1><p>最近在项目中遇到了需要搜索引擎的场景，对用户输入进行自动推荐和补全，elasticSearch是开源的搜索引引擎，入门使用也很简单。</p><p>怎么入门：</p><ol><li>类比入门：类比一个熟悉的知识点，知识迁移会更容易</li><li>简单的事例入门：动手进行简单的一个demo感受一下流程</li></ol><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="1-安装es"><a href="#1-安装es" class="headerlink" title="1.安装es"></a>1.安装es</h3><p>前置条件：mac环境(其他环境自行google)，brew工具安装好了，java环境安装好了</p><p>步骤：</p><ol><li>安装es：<ul><li>brew install elasticsearch</li><li>es服务端会被安装</li></ul></li><li>安装kibana：<ul><li>brew install kibana</li><li>kibana可以理解为图形化的es客户端</li></ul></li><li>启动es：brew services start elasticsearch</li><li>启动kibana：brew services start kibana</li></ol><p>安装es成功之后访问<code>http://localhost:9200/</code>可以获得es的状态信息<br>安装kibana成功之后访问<code>http://localhost:5601/app/kibana#/dev_tools/console?_g=()</code>可以对es进行操作</p><h3 id="2-自动补全"><a href="#2-自动补全" class="headerlink" title="2.自动补全"></a>2.自动补全</h3><pre><code>// hashtag{    id,    name,    score, // weight}</code></pre><h4 id="mappings-amp-analysizer"><a href="#mappings-amp-analysizer" class="headerlink" title="mappings &amp; analysizer"></a>mappings &amp; analysizer</h4><pre><code>PUT feed_id{    &quot;mappings&quot;: {        &quot;hashtag&quot;: {            &quot;properties&quot;: {                &quot;name&quot;: {                    &quot;type&quot;: &quot;completion&quot;                 }            }        }    }}</code></pre><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><pre><code>POST feed_id/hashtag{    &quot;name&quot;: {        &quot;input&quot;: [&quot;hashtag name&quot;],        &quot;weight&quot;: 2    }}POST feed_id/hashtag/3{    &quot;name&quot;: {        &quot;input&quot;: [&quot;hashtag name2&quot;],        &quot;weight&quot;: 3    }}POST feed_id/hashtag/4{    &quot;name&quot;: {        &quot;input&quot;: [&quot;ashtag name2&quot;],        &quot;weight&quot;: 4    }}POST feed_id/hashtag/5{    &quot;name&quot;: {        &quot;input&quot;: [&quot;shtag name2&quot;],        &quot;weight&quot;: 5    }}POST feed_id/hashtag/6{    &quot;name&quot;: {        &quot;input&quot;: [&quot;htag name2&quot;],        &quot;weight&quot;: 6    }}POST feed_id/hashtag/7{    &quot;name&quot;: {        &quot;input&quot;: [&quot;爱我中华&quot;],        &quot;weight&quot;: 6    }}POST feed_id/hashtag/8{    &quot;name&quot;: {        &quot;input&quot;: [&quot;爱你中华&quot;],        &quot;weight&quot;: 6    }}POST feed_id/hashtag/9{    &quot;name&quot;: {        &quot;input&quot;: [&quot;爱你&quot;],        &quot;weight&quot;: 6    }}</code></pre><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><pre><code>POST feed_id/_search?pretty{    &quot;suggest&quot;: {        &quot;hashtag-suggest&quot;: {            &quot;prefix&quot;: &quot;h&quot;,            &quot;completion&quot;: {                &quot;field&quot;: &quot;name&quot;            }        }    }}</code></pre><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>摘抄自<a href="ttps://github.com/looly/elasticsearch-definitive-guide-cn" target="_blank" rel="noopener">elasticsearch-definitive-guide-cn</a></p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;elasticSearch入门&quot;&gt;&lt;a href=&quot;#elasticSearch入门&quot; class=&quot;headerlink&quot; title=&quot;elasticSearch入门&quot;&gt;&lt;/a&gt;elasticSearch入门&lt;/h1&gt;&lt;p&gt;最近在项目中遇到了需要搜索引擎的场景
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>记timeline重构</title>
    <link href="http://lqczzz.github.io/2018/10/13/%E8%AE%B0timeline%E9%87%8D%E6%9E%84/"/>
    <id>http://lqczzz.github.io/2018/10/13/记timeline重构/</id>
    <published>2018-10-12T22:28:45.000Z</published>
    <updated>2018-10-18T07:24:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>timeline重构任重道远</p><p>所以，接下来很多笔记大概都会和timeline相关</p><ol><li>内存管理: 周四周五</li><li>golang性能分析工具：周末<ul><li>pprof</li><li>go bentch test</li></ul></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;timeline重构任重道远&lt;/p&gt;
&lt;p&gt;所以，接下来很多笔记大概都会和timeline相关&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存管理: 周四周五&lt;/li&gt;
&lt;li&gt;golang性能分析工具：周末&lt;ul&gt;
&lt;li&gt;pprof&lt;/li&gt;
&lt;li&gt;go bentch test&lt;/l
      
    
    </summary>
    
    
      <category term="timeline重构任重道远" scheme="http://lqczzz.github.io/tags/timeline%E9%87%8D%E6%9E%84%E4%BB%BB%E9%87%8D%E9%81%93%E8%BF%9C/"/>
    
  </entry>
  
  <entry>
    <title>golang并发学习笔记</title>
    <link href="http://lqczzz.github.io/2018/10/13/golang%E5%B9%B6%E5%8F%91/"/>
    <id>http://lqczzz.github.io/2018/10/13/golang并发/</id>
    <published>2018-10-12T22:28:05.000Z</published>
    <updated>2018-10-14T16:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang的并发模型叫做CSP（communicating sequential process），称为通信顺序进程模型，模型由独立并发执行的实体组成（go块），模型之间的通信通过channel来实现。因此，golang的并发模型哲学是：万物皆通信！！golang的核心概念主要是：</p><ol><li>channel</li><li>go块</li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><ul><li>channel可以单独创建，在进程之间传递</li><li>channel是<code>线程安全</code>队列，任何持有channel引用的任务(go块)都可以读写channel</li><li>channel默认是无缓冲区的，也就是channel本身是同步的，一端写数据操作必然会阻塞直到channel的数据被别的地方读取</li><li><p>channel可以关闭，向关闭的channel读数据会读到的默认值，向关闭的channel写数据会导致panic！！</p><pre><code>func main() {    ch := make(chan int)    go func() {        ch &lt;- 20        close(ch)        ch &lt;- 30 //panic: send on closed channel    }()    println(&lt;-ch) // 20    println(&lt;-ch) // 0(默认值)}</code></pre></li><li><p>有缓冲区的channel，根据缓冲区已满时候的策略，可以分为</p><ul><li>阻塞型：写入阻塞</li><li>弃用新值：新值写入被抛弃</li><li>移除旧值：太旧的数据被channel抛弃</li></ul></li><li><p>channel和队列很像<br>  在 <code>golang</code>里，channel可以用 <code>for i := range channelName {}</code>循环获取channel信息</p></li></ul><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><h3 id="线程模型的缺点"><a href="#线程模型的缺点" class="headerlink" title="线程模型的缺点"></a>线程模型的缺点</h3><p>java和c++的并发模型都是线程模型，它的好处是直接对硬件的抽象，大多数语言，包括python，它的线程模型都是操作系统线程，但是坏处是使用复杂。</p><p>但是线程模型有三个危害</p><blockquote><ol><li>竞态条件</li><li>死锁</li><li>内存可见性问题<br>引用自《七周七并发编程模型》</li></ol></blockquote><pre><code>public class Test {    static boolean ready = false;   // 竞态条件一：共享变量    static int data = 0    static Thread t1 = new Thread() {        public void run() {            data = 10;  // 竞态条件二：会有并行实体(线程)修改变量            ready = true;        }    };    static Thread t2 = new Thread() {        public void run() {            if (ready) {    // 竞态条件三：一个未处理完成另外一个处理可能会介入                System.out.Println(&quot;data is :&quot; + data)            } else {                System.out.Println(&quot;no data&quot;)            }        }    };    public static void main(String[] args) throw InterruptedException{        t1.start();        t2.start();        t1.join();        t2.join();    }}</code></pre><p>尽管线程模型问题很多，但是线程模型是其他模型的基础，比如nodejs的异步io模型，本质上也是基于线程池技术实现的，java的nio底层实现也是基于线程池。</p><p>线程池是多线程模型的改良，线程的启动和运行都有一定的开销，为了避免直接创建线程，才有了线程池，线程池方便了线程的复用，但是涉及线程通信的时候，如果线程被阻塞，那这个线程的资源永远都被占用者，线程池就显得鸡肋了。nodejs的决绝方法是限制程序员的代码风格，使之变成<code>事件驱动</code>的形式。</p><h3 id="goroutine调度机制和状态机"><a href="#goroutine调度机制和状态机" class="headerlink" title="goroutine调度机制和状态机"></a>goroutine调度机制和状态机</h3><p>所谓事件驱动是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。</p><p>node.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（ emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束，因此，node.js 是单线程，异步非阻塞</p><p>node的这种方式有几个问题：</p><ol><li>CPU密集型任务存在短板</li><li>无法利用CPU的多核</li><li>代码变得难以阅读</li><li>回调函数保存数据需要经常用到全局变量</li></ol><p>golang本质上也是使用了事件驱动的机制，但是这个过程对我们是透明的，主要解决了第三个问题，原理是把每个go块(<code>go func(){}()</code>)当层成了一个状态机，当go块从channel里读写，遇到阻塞的时候，go块进入暂停状态，让出线程控制权，代码可以继续进行的时候，状态扭转，go块继续运行(可能不在原来的线程上了) </p><h4 id="goroutine和线程"><a href="#goroutine和线程" class="headerlink" title="goroutine和线程"></a>goroutine和线程</h4><ul><li>每个os线程有一个固定大小的栈内存（通常2MB）</li><li>goroutine的栈空间大小不固定，开始通常是2KB，按需扩展，最大可达1GB</li><li>go运行时候有自己的goroutine调度算法，称为m：n调度，m个goroutine运行在n个线程上</li></ul><p>同是调度算法，为何go的调度算法如此优秀？</p><p>其实不然，和操作系统线程调度器对比，主要不同在于：</p><ol><li>os内核调度上下文切换开销大，go调度器只需要调度一个go程序自己的goroutine，更容易hold住</li><li>os调度是硬件时钟中断触发的，goroutine调度的触发是channel读写阻塞或者<code>time.Sleep()</code>来实现的，因此不需要切换到内核态。</li></ol><blockquote><p>goroutine没有标识，线程是有自己的标识的，因此可以方便的实现一个线程局部变量(<code>map[thread_symbol]object</code>),在web服务器上，线程局部变量通常会被用来存储http请求信息。在goroutine上没有这种机制，鼓励更简单的编程风格。<br>——《go程序设计语言》</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;golang的并发模型叫做CSP（communicating sequential process），称为通信顺序进程模型，模型由独立并发执行的实体组成（go块），模型之间的通信通过channel来实现。因此，golang的并发模型哲学是：万物皆通信！！golang的核心概
      
    
    </summary>
    
    
      <category term="golang" scheme="http://lqczzz.github.io/tags/golang/"/>
    
      <category term="并发" scheme="http://lqczzz.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
