<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="关于《unix网络编程》unix网络编程这书分为两册：  一册讲socket编程，700多页，31章 二册讲进程之间的通信，400页，16章  看目录可以看出，最基础最核心的知识在：  chapter1: 简介 chapter2: tcp／udp和stcp(这玩意不管) chapter3: 套接字编程简介 chapter4: 基本tcp套接字编程 chapter5: tcp客户／服务端程序实例">
<meta name="keywords" content="tcp&#x2F;ip">
<meta property="og:type" content="article">
<meta property="og:title" content="unix网络编程笔记-tcp编程基础">
<meta property="og:url" content="http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="关于《unix网络编程》unix网络编程这书分为两册：  一册讲socket编程，700多页，31章 二册讲进程之间的通信，400页，16章  看目录可以看出，最基础最核心的知识在：  chapter1: 简介 chapter2: tcp／udp和stcp(这玩意不管) chapter3: 套接字编程简介 chapter4: 基本tcp套接字编程 chapter5: tcp客户／服务端程序实例">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://lqczzz.github.io/images/net/分组交换协议.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/1.1.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/osi和网际协议的对应关系.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/bug_coreserver.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/2.1总图.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/基本的tcp_socket函数.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/tcp三次握手.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/tcp四次挥手.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/tcp状态转换.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/tcp连接分组交换.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/并发服务器.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/socket_family.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/socket_type.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/socket_protocol.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/listen的内核队列.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/三次握手和队列.png">
<meta property="og:image" content="http://lqczzz.github.io/images/net/并发服务器套接字.png">
<meta property="og:updated_time" content="2018-10-24T15:24:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="unix网络编程笔记-tcp编程基础">
<meta name="twitter:description" content="关于《unix网络编程》unix网络编程这书分为两册：  一册讲socket编程，700多页，31章 二册讲进程之间的通信，400页，16章  看目录可以看出，最基础最核心的知识在：  chapter1: 简介 chapter2: tcp／udp和stcp(这玩意不管) chapter3: 套接字编程简介 chapter4: 基本tcp套接字编程 chapter5: tcp客户／服务端程序实例">
<meta name="twitter:image" content="http://lqczzz.github.io/images/net/分组交换协议.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>unix网络编程笔记-tcp编程基础</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/lqczzz?tab=projects">项目</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2018/10/26/break-in-golang/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2018/10/18/优秀的博文记录/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&text=unix网络编程笔记-tcp编程基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&is_video=false&description=unix网络编程笔记-tcp编程基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=unix网络编程笔记-tcp编程基础&body=Check out this article: http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&name=unix网络编程笔记-tcp编程基础&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于《unix网络编程》"><span class="toc-number">1.</span> <span class="toc-text">关于《unix网络编程》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阅读前提"><span class="toc-number">2.</span> <span class="toc-text">阅读前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter0-简介"><span class="toc-number">3.</span> <span class="toc-text">chapter0:简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从现代交换技术说起"><span class="toc-number">3.1.</span> <span class="toc-text">从现代交换技术说起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chapter1-分组交换协议"><span class="toc-number">3.2.</span> <span class="toc-text">chapter1:分组交换协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp／ip简介"><span class="toc-number">3.3.</span> <span class="toc-text">tcp／ip简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#案例分析"><span class="toc-number">3.3.1.</span> <span class="toc-text">案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bug"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">bug</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原因"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">解决</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter2-传输层：tcp-udp-sctp"><span class="toc-number">4.</span> <span class="toc-text">chapter2:传输层：tcp/udp/sctp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP协议族"><span class="toc-number">4.1.</span> <span class="toc-text">TCP/UDP协议族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手和四次挥手"><span class="toc-number">4.2.</span> <span class="toc-text">三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手"><span class="toc-number">4.2.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四次挥手"><span class="toc-number">4.2.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp状态转换"><span class="toc-number">4.2.3.</span> <span class="toc-text">tcp状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time-wait状态"><span class="toc-number">4.2.4.</span> <span class="toc-text">time_wait状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket-pair"><span class="toc-number">4.2.5.</span> <span class="toc-text">socket pair</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter3-套接字编程简介"><span class="toc-number">5.</span> <span class="toc-text">chapter3:套接字编程简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter4-基本tcp套接字编程"><span class="toc-number">6.</span> <span class="toc-text">chapter4:基本tcp套接字编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-socket函数"><span class="toc-number">6.1.</span> <span class="toc-text">1. socket函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-connect函数"><span class="toc-number">6.2.</span> <span class="toc-text">2. connect函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-bind函数"><span class="toc-number">6.3.</span> <span class="toc-text">3. bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-listen函数"><span class="toc-number">6.4.</span> <span class="toc-text">4. listen函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-accept函数"><span class="toc-number">6.5.</span> <span class="toc-text">5. accept函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发服务器基本原理："><span class="toc-number">6.6.</span> <span class="toc-text">并发服务器基本原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter5-tcp客户／服务程序示例"><span class="toc-number">7.</span> <span class="toc-text">chapter5:tcp客户／服务程序示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter30-客户／服务器程序设计范式"><span class="toc-number">8.</span> <span class="toc-text">chapter30:客户／服务器程序设计范式</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        unix网络编程笔记-tcp编程基础
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Hexo</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2018-10-21T06:00:26.000Z" itemprop="datePublished">2018-10-21</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/tcp-ip/">tcp/ip</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="关于《unix网络编程》"><a href="#关于《unix网络编程》" class="headerlink" title="关于《unix网络编程》"></a>关于《unix网络编程》</h2><p>unix网络编程这书分为两册：</p>
<ol>
<li>一册讲socket编程，700多页，31章</li>
<li>二册讲进程之间的通信，400页，16章</li>
</ol>
<p>看目录可以看出，最基础最核心的知识在：</p>
<ul>
<li>chapter1: 简介</li>
<li>chapter2: tcp／udp和stcp(这玩意不管)</li>
<li>chapter3: 套接字编程简介</li>
<li>chapter4: 基本tcp套接字编程</li>
<li>chapter5: tcp客户／服务端程序实例</li>
<li>chapter30: 客户／服务程序设计范式</li>
</ul>
<p>感觉这几章学完了就差不多够了，其他章节需要再读～</p>
<h2 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h2><p>假设你对OSI七层模型有所了解</p>
<h2 id="chapter0-简介"><a href="#chapter0-简介" class="headerlink" title="chapter0:简介"></a>chapter0:简介</h2><h3 id="从现代交换技术说起"><a href="#从现代交换技术说起" class="headerlink" title="从现代交换技术说起"></a>从现代交换技术说起</h3><p>《现代交换技术》是通信专业的必修课，嗯嗯，好歹我也是通信专业的学生，就先把知识脉络拓展一下～</p>
<p>现代交换技术的分类：</p>
<ol>
<li>电路交换</li>
<li>分组交换</li>
</ol>
<p>计算机网络的协议用的就是分组交换技术，我们发送的信息会像快递包裹一样一个个的传送到接收方。而电路交换很简单，就是每个通信实体都连接到交换机上，而交换机使用交换的方法，让实体之间可以很方便地通信，现在最广泛的应用就是电话网络了。<br>从打电话也可以看出来，电路交换一定是：</p>
<ol>
<li>面向连接；(分组交换则不一定，如udp协议)</li>
<li>同步时分复用；</li>
<li>信息传送无差错控制；</li>
</ol>
<h3 id="chapter1-分组交换协议"><a href="#chapter1-分组交换协议" class="headerlink" title="chapter1:分组交换协议"></a>chapter1:分组交换协议</h3><p><img src="/images/net/分组交换协议.png" alt="分组交换协议"></p>
<ol>
<li>PDU: 协议数据单元，即对等实体(处于同一层)之间的交换单元信息</li>
<li>SDU: 下一层承载上一层数据的单元，比如tcp层传输的tcp报文(报文头+报文体)数据在tcp层就是一个PDU，传给ip层之后，ip层认为它是SDU（ip层在tcp报文之外加入ip报文头，类似俄罗斯套娃）</li>
</ol>
<p>不同协议之间的不同完全取决于协议头（废话～）</p>
<h3 id="tcp／ip简介"><a href="#tcp／ip简介" class="headerlink" title="tcp／ip简介"></a>tcp／ip简介</h3><ol>
<li>一般认为web服务器程序是长时间运行的程序，即所谓的守护程序</li>
<li>用户进程定义应用协议，tcp和ip协议的转换和包装在内核协议栈中，由操作系统提供支持<br><img src="/images/net/1.1.png" alt=""></li>
<li><p>tcp是没有记录边界的字节流协议</p>
<ul>
<li>tcp应用进程之间是没有长度限制的字节流，udp进程交换的数据长度不能超过udp发送缓冲区大小的单个记录(record)</li>
<li>tcp协议：应用程序一次次输出操作写到socket的数据经过顺序分割，得到分节(segment)，<em>数据量太大的时候，我们无法确保一次read到所有的数据，所以必须要把read编写在某个循环中</em></li>
<li>tcp没有边界,所以tcp服务需要自己实现，提供一个表示长度的协议头</li>
</ul>
</li>
<li>ip报文的SDU最大是65535，所以tcp一次发送的报文大小不会超过64k<br> 对于平常实用的<code>conn.Write([]byte)</code>，我们是不用考虑这些，操作系统会对这类阻塞写操作进行自动分片并且不用考虑缓冲区写满的情况</li>
<li>套接字编程是应用层进入传输层的接口<ul>
<li>这样设计由两个理由：<ol>
<li>应用层对通信细节很少关心，而底下四层对应用协议不关心，只关心如何通信</li>
<li>应用层常构成用户进程，地下四层作为操作系统和内核的机制，存在与内核态</li>
</ol>
</li>
<li>socket可以绕过tcp和udp直接实用ipv4/ipv6，这种socket称为原始套接字(raw socket),很少用到，在整本书里面第28章介绍了它的两个用途：<ol>
<li>ping</li>
<li>traceroute<br>因此不打算深入了解了</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><img src="/images/net/osi和网际协议的对应关系.png" alt="osi和网际协议的对应关系"></p>
<ol>
<li><code>netstat</code>和<code>ifconfig</code>可以很方便的查看网络的细节</li>
</ol>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><h5 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h5><p>这里记录一个工作中遇到的bug：</p>
<pre><code>// 没有for循环读取数据
func request(conn net.Conn, buffer bytes.Buffer, command []byte) error {

    // 读协议头，得到body的长度
    recvBuf := make([]byte, 4)
    resHead := binary.LittleEndian.Uint32(recvBuf)

    // 指定读取数据的大小，读取数据，bug:读取不完整
    var resBody bytes.Buffer
    recvBuf = make([]byte, resHead)
    length, err := conn.Read(recvBuf)
    if err != nil {
        return err
    }
    return nil
}
</code></pre><p>bug分析：</p>
<h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ol>
<li>原因1:</li>
</ol>
<p><img src="/images/net/bug_coreserver.png" alt="bug"><br>socket上的read和write(操作系统的系统调用)不同于通常的文件读写，可能的到的字节数比预期的要少，原因在于内核缓冲区可能数据不够(read)或者缓冲区已经满了(non block write),上面的主要问题是read的时候缓冲区的数据不够，在项目中，由于网络原因，当我们</p>
<pre><code>var recvData = make([]byte, Size)
conn.Read(recvData)
</code></pre><p>这样获取数据，由于网络不稳定，可能缓冲区的数据足够，可能不够，所以出现了调用20次成功一次的情况<br>既然如此,为什么go实现<code>conn.Read()</code>为什么不帮我们阻塞去等待数据的到来呢</p>
<p>很遗憾<code>Read</code>没有这样的能力，go也没有提供类似c的<code>Readn</code>这样的接口</p>
<blockquote>
<p>If some data is available but not len(p) bytes, Read conventionally returns what is available instead of waiting for more.<br>来自 go io包Read接口的注释</p>
</blockquote>
<ol>
<li><p>原因2:</p>
<p> 不知道服务器端发送的逻辑(也不应该依赖它)，可能是</p>
<pre><code>for {
    conn.Write() // 手动分片
}
</code></pre><p> 也可能是：</p>
<pre><code>conn.Write([]整个数据)
</code></pre></li>
</ol>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>套一层for循环</p>
<pre><code>// 修改成for循环读取数据，bug解决
func request(conn net.Conn, buffer bytes.Buffer, command []byte) error {

    // 读协议头，得到body的长度
    recvBuf := make([]byte, 4)
    resHead := binary.LittleEndian.Uint32(recvBuf)

    // 指定读取数据的大小，读取数据，bug:读取不完整
    var resBody bytes.Buffer
    recvBuf = make([]byte, resHead)
    for resBody.Len() &lt; int(resHead) {
        length, err := conn.Read(recvBuf)
        if err != nil {
            return err
        }

        resBody.Write(recvBuf[:length])
    }
    return nil
  }
</code></pre><h2 id="chapter2-传输层：tcp-udp-sctp"><a href="#chapter2-传输层：tcp-udp-sctp" class="headerlink" title="chapter2:传输层：tcp/udp/sctp"></a>chapter2:传输层：tcp/udp/sctp</h2><p>主要讲了UDP／TCP／SCTP三种协议，SCTP日常用的少，以后再了解，重点讲了TCP编程，部分笔记来自第三章(方便总结)</p>
<h3 id="TCP-UDP协议族"><a href="#TCP-UDP协议族" class="headerlink" title="TCP/UDP协议族"></a>TCP/UDP协议族</h3><p><img src="/images/net/2.1总图.png" alt="总图"></p>
<ol>
<li>ipv4/ipv6对上层协议提供了分组递送的能力，不具有可靠性(丢包可能)</li>
<li>tcp是面向连接的流式套接字(stream socket)，关心确认／超时／重传的细节<ul>
<li>需要三次握手建立连接</li>
<li>源端数据发送需要对端确认，一段时间内(超时时间:RTT)收不到确认应答则重传，多次重传失败则终止传输<ul>
<li>RTT(round-trip time)一次客户端和服务器端往返时间</li>
</ul>
</li>
<li>流量控制：接收方可以告诉发送方下一次我能接受的数据量，防止接收方缓冲区溢出</li>
<li>tcp是全双工的</li>
</ul>
</li>
<li>udp是一种无连接的数据包报套接字(datagram socket)：<ul>
<li>不保证是否到达</li>
<li>不保证到达顺序</li>
<li>没有自动重传</li>
<li>没有超时概念</li>
<li>每个数据包都都有报文头标示长度等</li>
</ul>
</li>
</ol>
<h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/images/net/基本的tcp_socket函数.png" alt="基本socket函数for tcp"></p>
<p>上图来自第五章，展示了基本的一个tcp客户端和服务端的socket系统调用函数的关系，具体每个系统调用的作用在下面总结。这里关心的是三次握手触发的时机:<em>服务端调用了accept，客户端调用connect主动打开</em></p>
<p><img src="/images/net/tcp三次握手.png" alt="三次握手"></p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/images/net/tcp四次挥手.png" alt="四次挥手"></p>
<ol>
<li>主动关闭方(客户端)发送fin分节，意思是我该说的说完了，服务器收到立马回复说我收到了,然后这个分节放到服务端的缓冲区的末尾，等待应用程序处理</li>
<li>应用程序处理完了，服务端也需要发一个fin告诉客户端我也完事了</li>
<li>在服务端发送这两个分节的过程中，服务端仍然可以向客户端发送数据</li>
<li>缓冲队列没有数据，服务端也不需要发送数据的时候，服务端会合并发送<code>ack m+1</code>和<code>fin n</code>分节，这时候就是三次挥手了。</li>
<li>主动关闭方(客户端)响应了服务端的fin分节之后，会再等一段时间，进入<code>time_wait</code>状态，</li>
<li>tcp是全双工的，任何一方都可以关闭，通常是客户端关闭</li>
</ol>
<h4 id="tcp状态转换"><a href="#tcp状态转换" class="headerlink" title="tcp状态转换"></a>tcp状态转换</h4><p><img src="/images/net/tcp状态转换.png" alt="tcp状态转换"></p>
<p><img src="/images/net/tcp连接分组交换.png" alt="tcp连接分组交换"></p>
<h4 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time_wait状态"></a>time_wait状态</h4><ol>
<li>可靠的实现全双工连接的终止：<br> 如果最后一个ack n+1没有发送给服务端，服务端会重新发送FIN N，这种情况<strong>至少</strong>花费一次来回(&gt;=2MSL)，因此time_wait需要有至少2MSL的时间间隔</li>
<li>允许老的重复分节消逝，主要是防止新的连接如果用了同样的ip和端口，被认为和上一次是同一个连接</li>
</ol>
<h4 id="socket-pair"><a href="#socket-pair" class="headerlink" title="socket pair"></a>socket pair</h4><p>socket pair即<code>(src_ip, src_port, dest_ip, dest_port)</code>唯一确认一个tcp连接</p>
<p><img src="/images/net/并发服务器.png" alt="并发服务器"></p>
<p>如上图，当两个客户端连接同一个socket的时候，无法通过服务端socket的ip和port唯一确认一个连接。详细原因看chapter4</p>
<h2 id="chapter3-套接字编程简介"><a href="#chapter3-套接字编程简介" class="headerlink" title="chapter3:套接字编程简介"></a>chapter3:套接字编程简介</h2><ol>
<li>网际协议采用大端字节传递多字节数（网络字节序）<ul>
<li>大端字节序：高位内存地址对应高序字节</li>
<li>小端字节序：低位内存地址对应高序字节</li>
</ul>
</li>
</ol>
<h2 id="chapter4-基本tcp套接字编程"><a href="#chapter4-基本tcp套接字编程" class="headerlink" title="chapter4:基本tcp套接字编程"></a>chapter4:基本tcp套接字编程</h2><h3 id="1-socket函数"><a href="#1-socket函数" class="headerlink" title="1. socket函数"></a>1. <code>socket</code>函数</h3><pre><code>// 执行网络io前的第一步：socket()
#include&lt;sys/socket.h&gt;
int socket(int family, int type, int protocol)
</code></pre><ul>
<li>family<br>  <img src="/images/net/socket_family.png" alt=""></li>
<li>type<br>  <img src="/images/net/socket_type.png" alt=""></li>
<li>protocol<br>  <img src="/images/net/socket_protocol.png" alt=""></li>
</ul>
<p><code>socket</code>函数调用成功会返回一个套接字描述符(类似文件描述符),只要指定协议族和套接字类型。</p>
<p>套接字(socket)和套接字描述符(discriptor)是一对多的关系（一个socket可以有对应多个discriptor）</p>
<h3 id="2-connect函数"><a href="#2-connect函数" class="headerlink" title="2. connect函数"></a>2. <code>connect</code>函数</h3><p>客户端调用<code>connect</code>函数建立tcp连接，调用<code>connect</code>之前不必调用<code>bind</code>，系统会确定源ip地址并且默认选择一个临时端口作为源端口。</p>
<pre><code>int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen)
</code></pre><p>connect触发三次握手的过程,这时候有几种结果：</p>
<ol>
<li>成功</li>
<li>第一个<code>SYN</code>分节没有受到<code>ACK</code>，则重试，重试也失败了，返回<code>ETIMEOUT</code>错误</li>
<li>返回的分节不是<code>ACK</code>，是<code>RST</code>。返回<code>ECONNREFUSED</code><ul>
<li><code>RST</code>出现有三个条件：<ol>
<li>目标主机收到<code>SYN</code>分节,但是没有监听这个端口的服务器进程</li>
<li>tcp想取消一个已有的连接</li>
<li>tcp收到的分节不属于这个连接</li>
</ol>
</li>
</ul>
</li>
<li>ICMP路由不可达错误，客户端会重试</li>
</ol>
<h3 id="3-bind函数"><a href="#3-bind函数" class="headerlink" title="3. bind函数"></a>3. <code>bind</code>函数</h3><pre><code>int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)
</code></pre><p><code>bind</code>函数用于给socket地址赋予一个协议地址(ip+port)<br>服务器程序通常需要使用<code>bind</code>，客户端则由系统分配就好</p>
<p><code>bind</code>函数常见返回错误是<code>Address aready in use</code></p>
<h3 id="4-listen函数"><a href="#4-listen函数" class="headerlink" title="4. listen函数"></a>4. <code>listen</code>函数</h3><pre><code>int listen(int sockfd, int backlog)
</code></pre><p><code>socket</code>函数得到的套接字默认是主动套接字，即系统认为它以后是要去做<code>connect</code>发起连接的<br>而<code>listen</code>函数的作用有二：</p>
<ol>
<li>将主动转被动，告诉系统“我不该主动，我该接受指向这个套接字的请求”</li>
<li><code>backlog</code>指定了内核为这个socket排队的最大连接个数(有的操作系统增加了一个模糊因子，<code>backlog</code>作为一个和最大连接数正相关的值)，内核有两个队列<br><img src="/images/net/listen的内核队列.png" alt=""></li>
</ol>
<p>三次握手的过程：<br><img src="/images/net/三次握手和队列.png" alt=""></p>
<ol>
<li>通常RTT平均在187ms</li>
<li>未完成队列满了对继续过来的请求分节丢弃不处理（因为客户端会重传）</li>
</ol>
<h3 id="5-accept函数"><a href="#5-accept函数" class="headerlink" title="5. accept函数"></a>5. <code>accept</code>函数</h3><pre><code>int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen)
</code></pre><p><code>accept</code>函数会从完成队列头push一个连接，由内核生成一个已连接套接字(connected socket)，一个服务进程通常持有一个<code>listening socket</code>（监听套接字）,n个<code>connect socket</code>（每个客户端一个）</p>
<h3 id="并发服务器基本原理："><a href="#并发服务器基本原理：" class="headerlink" title="并发服务器基本原理："></a>并发服务器基本原理：</h3><p>基础：文件描述符和socket描述符有一个引用计数器，被引用一次则加一，没有引用才会被清理</p>
<p><img src="/images/net/并发服务器套接字.png" alt=""></p>
<h2 id="chapter5-tcp客户／服务程序示例"><a href="#chapter5-tcp客户／服务程序示例" class="headerlink" title="chapter5:tcp客户／服务程序示例"></a>chapter5:tcp客户／服务程序示例</h2><h2 id="chapter30-客户／服务器程序设计范式"><a href="#chapter30-客户／服务器程序设计范式" class="headerlink" title="chapter30:客户／服务器程序设计范式"></a>chapter30:客户／服务器程序设计范式</h2><blockquote>
<p>《unix网络编程卷一》<br>《图解tcp/ip》</p>
</blockquote>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/lqczzz?tab=projects">项目</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关于《unix网络编程》"><span class="toc-number">1.</span> <span class="toc-text">关于《unix网络编程》</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阅读前提"><span class="toc-number">2.</span> <span class="toc-text">阅读前提</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter0-简介"><span class="toc-number">3.</span> <span class="toc-text">chapter0:简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从现代交换技术说起"><span class="toc-number">3.1.</span> <span class="toc-text">从现代交换技术说起</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chapter1-分组交换协议"><span class="toc-number">3.2.</span> <span class="toc-text">chapter1:分组交换协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp／ip简介"><span class="toc-number">3.3.</span> <span class="toc-text">tcp／ip简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#案例分析"><span class="toc-number">3.3.1.</span> <span class="toc-text">案例分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bug"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">bug</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#原因"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">解决</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter2-传输层：tcp-udp-sctp"><span class="toc-number">4.</span> <span class="toc-text">chapter2:传输层：tcp/udp/sctp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-UDP协议族"><span class="toc-number">4.1.</span> <span class="toc-text">TCP/UDP协议族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手和四次挥手"><span class="toc-number">4.2.</span> <span class="toc-text">三次握手和四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三次握手"><span class="toc-number">4.2.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四次挥手"><span class="toc-number">4.2.2.</span> <span class="toc-text">四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tcp状态转换"><span class="toc-number">4.2.3.</span> <span class="toc-text">tcp状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time-wait状态"><span class="toc-number">4.2.4.</span> <span class="toc-text">time_wait状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socket-pair"><span class="toc-number">4.2.5.</span> <span class="toc-text">socket pair</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter3-套接字编程简介"><span class="toc-number">5.</span> <span class="toc-text">chapter3:套接字编程简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter4-基本tcp套接字编程"><span class="toc-number">6.</span> <span class="toc-text">chapter4:基本tcp套接字编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-socket函数"><span class="toc-number">6.1.</span> <span class="toc-text">1. socket函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-connect函数"><span class="toc-number">6.2.</span> <span class="toc-text">2. connect函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-bind函数"><span class="toc-number">6.3.</span> <span class="toc-text">3. bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-listen函数"><span class="toc-number">6.4.</span> <span class="toc-text">4. listen函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-accept函数"><span class="toc-number">6.5.</span> <span class="toc-text">5. accept函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发服务器基本原理："><span class="toc-number">6.6.</span> <span class="toc-text">并发服务器基本原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter5-tcp客户／服务程序示例"><span class="toc-number">7.</span> <span class="toc-text">chapter5:tcp客户／服务程序示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chapter30-客户／服务器程序设计范式"><span class="toc-number">8.</span> <span class="toc-text">chapter30:客户／服务器程序设计范式</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&text=unix网络编程笔记-tcp编程基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&is_video=false&description=unix网络编程笔记-tcp编程基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=unix网络编程笔记-tcp编程基础&body=Check out this article: http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&title=unix网络编程笔记-tcp编程基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://lqczzz.github.io/2018/10/21/unix网络编程笔记-tcp编程基础/&name=unix网络编程笔记-tcp编程基础&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 lqczzz
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">首页</a></li>
         
          <li><a href="/about/">关于</a></li>
         
          <li><a href="/archives/">归档</a></li>
         
          <li><a href="https://github.com/lqczzz?tab=projects">项目</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">

    <!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<!-- clipboard -->

  <script src="/lib/clipboard/clipboard.min.js"></script>
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight .code pre").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>

<script src="/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


</body>
</html>
